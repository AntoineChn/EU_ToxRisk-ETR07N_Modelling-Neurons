---
title: "step_by_step_X_CIa_MTa_PRa_NRa"
output:
  html_document:
    toc: true
    toc_depth: 3
    code_folding: hide
    number_sections: true
    toc_float:
      collapsed: false
      smooth_scroll: false
    fig_caption: true
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = '..')
knitr::opts_chunk$set(
  cache = FALSE,
  out.width = "100%",
  fig.align = 'center',
  fig.width = 8,
  fig.asp = 0.618,  # 1 / phi
  fig.show = "hold",
  warning=FALSE, message=FALSE,
  eval = TRUE, echo = TRUE
)
```

```{r include=F}
file.copy("./img", "./Rnotebook", recursive=TRUE, overwrite=T)
```


```{r include=FALSE}
source("GlobalParameters.R")
pckToLoad = c('tidyverse', 'DT',  "threejs",
              "plyr","citr","readxl",'scales',"rstan","reshape2", 
              "bayesplot","gridExtra")
reloadpck()
```


Modelling qAOP using DBN

# AOP ETR07N

```{r echo=FALSE, out.width='100%'}
knitr::include_graphics('./img/AOP_ETR07N.png')
```

- Chemical : `Dose` for chemical concentration
- KE1 : `CIa` for complex I activity
- KE2 : `MTa` for Mitochondrial activity
- KE3 : `PRa` for proteostasis activity
- KE4 : `NRa` for Neurite Area

# Model description

Let's implement user specified linkind function for each Key event relationship.

## X -> CIa : Log-logistic

$$\begin{equation}
\begin{split}
y &= \frac{y_{max} - y_{min}}{1 + e^{-k\left(\ln(x) - \ln(x_{50}) \right)}} + y_{min}\\
y_{obs} &\sim \mathcal{N}(y, \sigma_{y}^2)
\end{split}
\end{equation}$$

Here

- $y$ : KE of interest : CIa
- $x$ : Parent node of $y$ in the AOP : Dose
- $x_{50}$ : the center of symmetry of the logistic (transformed $tanh()$) function.

## CIa -> MTa : truncated Linear

### Modelling CIa -> MTa

$$\begin{equation}
\begin{split}
y_{tmp} &= \beta x + \beta_{0} \\
y &= \begin{cases}
120 & \text{if $y_{tmp}>120$} \\
0   & \text{if $y_{tmp}<0$}   \\
y_{tmp} & \text{otherwise}
\end{cases}\\
y_{obs} &\sim \mathcal{N}(y, \sigma_{y}^2)
\end{split}
\end{equation}$$

Here

- $y$ : KE of interest : MTa
- $x$ : Parent node of $y$ in the AOP.
- $x_{50}$ : the center of symmetry of the logistic (transformed $tanh()$) function.

## MTa -> PRa : 

$$\begin{equation}
\begin{split}
y &= \frac{y_{max} - y_{min}}{1 + e^{-k(x - x_{50} )}} + y_{min}\\
y_{obs} &\sim \mathcal{N}(y, \sigma_{y}^2)
\end{split}
\end{equation}$$

Here

- $y$ : KE of interest : MTa
- $x$ : Parent node of $y$ in the AOP.
- $x_{50}$ : the center of symmetry of the logistic (transformed $tanh()$) function.

Wang fix following parameters as a temperar solution of idenfiability problem.

- $y_{min}  = 0$
- $y_{max}  = 100$

Wang does a change of parameter 

- $k = \exp(q)$

## NRa given (PRa, MTa)

### Inspiration (`Rotenone`) {.tabset .tabset-fade .tabset-pills}

1. Use 
    - the dose of MTa data set
    - the MAP point estimator of `step_by_step_X_CIa_MTa_PRa_*.stanFit`
to predict 
    - `CIa_pred` 
    - `MTa_pred`
    - `PRa_pred`
1. Plot `NRa` wrt `PRa_pred`

```{r results='hide',fig.keep='all'}
tmp.stanfile.name = "step_by_step_X_CIa_MTa_PRa"
list.files(glob_params$Stan$FitPath, pattern = tmp.stanfile.name)
fit_step_by_step_X_CIa_MTa_PRa =
  readr::read_rds(glob_params$Stan$f.FitPath("step_by_step_X_CIa_MTa_PRa_Chemi_Rotenone_Chain_3_iter_10000_seed_1907131311_1907131311.stanFit"))

tmp.fit = fit_step_by_step_X_CIa_MTa_PRa

tmp.parsName = c("CIa_min" ,
                 "CIa_max" ,
                 "Par_CIa_50" ,
                 "log_Par_CIa_50",
                 "k_CIa" ,
                 "sigma_CIa",
                 
                 "beta_MTa",
                 "beta_0_MTa",
                 "sigma_MTa",
                 
                 "PRa_min",
                 "PRa_max",
                 "Par_PRa_50",
                 "q_PRa",
                 "sigma_PRa",

                 "lp__")

## MAP
la_all = as.data.frame(rstan::extract(tmp.fit, pars = tmp.parsName))

la.map_all = la_all[which.max(la_all$lp__),]
la.summary_all = summary(tmp.fit,
                         probs = c(0.05, 0.95),
                         pars = tmp.parsName)$summary %>% as.data.frame()
la.mean_all = la.summary_all["mean"] %>% t() %>% as.data.frame()
```

```{r}
# ## Linking function
source(glob_params$f.RScript("CPDs.R")) ;

## Data
source(glob_params$f.RScript('load-and-reshape-Konstanz-data.R')) ;

tmp.chemi = "Rotenone"
tmp.data.KE1 = KE1.both %>% filter(., chemi == tmp.chemi, concentration_MuMol > 0)
tmp.data.KE2 = KE2.both %>% filter(., chemi == tmp.chemi, concentration_MuMol > 0)
tmp.data.KE3 = KE3.both %>% filter(., chemi == tmp.chemi, concentration_MuMol > 0)
tmp.data.KE4 = KE4.both %>% filter(., chemi == tmp.chemi, concentration_MuMol > 0)

tmp.est.ponct = la.map_all
# tmp.est.ponct = la.mean_all

# Parameters of stanFit for CIa
tmp.pars_CIa = list(y_min     = tmp.est.ponct$CIa_min,
                    y_max     = tmp.est.ponct$CIa_max,
                    x_50      = tmp.est.ponct$log_Par_CIa_50,
                    k         = tmp.est.ponct$k_CIa)
# Parameters of stanFit for MTa
tmp.pars_MTa = list(beta     = tmp.est.ponct$beta_MTa,
                    beta_0   = tmp.est.ponct$beta_0_MTa)

# Parameters of stanFit for PRa
tmp.pars_PRa = list(y_min     = tmp.est.ponct$PRa_min,
                    y_max     = tmp.est.ponct$PRa_max,
                    x_50      = tmp.est.ponct$Par_PRa_50,
                    k         = tmp.est.ponct$q_PRa %>% exp())

```


```{r eval = F, cache=T}
{
  p.data = tmp.data.KE1
  p = ggplot(data = p.data,
             aes(x = concentration_MuMol,
                 y = c1_activity))
  
  p +
    geom_point(aes(colour = replication)) +
    scale_x_continuous(limit=c(1E-4,50),trans = "log10") +
    scale_y_continuous(limit=c(0,150),oob=squish) +
    geom_smooth()
}

{
  p.data = tmp.data.KE2
  p = ggplot(data = p.data,
             aes(x = concentration_MuMol,
                 y = mito_resp))
  
  p +
    geom_point(aes(colour = replication)) +
    scale_x_continuous(limit=c(1E-4,50),trans = "log10") +
    scale_y_continuous(limit=c(0,150),oob=squish) +
    geom_smooth()
}

{
  p.data = tmp.data.KE3
  p = ggplot(data = p.data,
             aes(x = concentration_MuMol,
                 y = Prot_acti))
  
  p +
    geom_point(aes(colour = replication)) +
    scale_x_continuous(limit=c(1E-4,50),trans = "log10") +
    scale_y_continuous(limit=c(0,150),oob=squish) +
    geom_smooth()
}

{
  p.data = tmp.data.KE4
  p = ggplot(data = p.data,
             aes(x = concentration_MuMol,
                 y = Neurite_Area))
  
  p +
    geom_point(aes(colour = replication)) +
    scale_x_continuous(limit=c(1E-4,50),trans = "log10") +
    scale_y_continuous(limit=c(0,150),oob=squish) +
    geom_smooth()
}

```


```{r out.width = '100%', fig.asp = 1.5, cache=T}
p.data = tmp.data.KE4

p.data$CIa_pred_MAP = log(p.data$concentration_MuMol) %>% 
    f.link.lgstc(.,
                 params = tmp.pars_CIa)

p.data$MTa_pred_MAP = 
  f.link.linear(x = p.data$CIa_pred_MAP,
                params = tmp.pars_MTa) %>% 
  f.link.truncation(., lower = 0, upper = 120) 

p.data$PRa_pred_MAP = f.link.lgstc(p.data$MTa_pred_MAP,
                                   params = tmp.pars_PRa)

if(F){
  p.data$concentration_MuMol
  p.data$CIa_pred_MAP
  p.data$MTa_pred_MAP
  p.data$PRa_pred_MAP
  p.data$Neurite_Area
}

tmp.p.1 = ggplot(data = p.data,
           aes(x = concentration_MuMol,
               y = CIa_pred_MAP)) +
  geom_point(aes(colour = replication)) +
    scale_x_continuous(limit=c(1E-4,50),trans = "log10") +
    scale_y_continuous(limit=c(0,150),oob=squish)

tmp.p.2 = ggplot(data = p.data,
           aes(x = CIa_pred_MAP,
               y = MTa_pred_MAP)) +
  geom_point(aes(colour = replication)) +
    scale_x_continuous(limit=c(0,120)) +
    scale_y_continuous(limit=c(0,150),oob=squish)

tmp.p.3 = ggplot(data = p.data,
           aes(x = MTa_pred_MAP,
               y = PRa_pred_MAP)) +
  geom_point(aes(colour = replication)) +
    scale_x_continuous(limit=c(0,120)) +
    scale_y_continuous(limit=c(0,150),oob=squish)

grid.arrange(tmp.p.1, 
             tmp.p.2, 
             tmp.p.3,
             ncol=1)
```

### NRa wrt PRa / MTa

```{r}

ggplot(data = p.data,
           aes(x = PRa_pred_MAP,
               y = Neurite_Area)) +
  geom_point(aes(colour = replication)) +
    scale_x_continuous(limit=c(0,120)) +
    scale_y_continuous(limit=c(0,150),oob=squish)  +
  ggtitle("NRa wrt PRa")

ggplot(data = p.data,
           aes(x = MTa_pred_MAP,
               y = Neurite_Area)) +
  geom_point(aes(colour = replication)) +
    scale_x_continuous(limit=c(0,120)) +
    scale_y_continuous(limit=c(0,150),oob=squish) +
  geom_line(aes(group = replication, colour = replication)) +
  ggtitle("NRa wrt MTa")
  
```

```{r}
library(rgl)

nrep  = p.data$replication %>% unique %>% length()
repID = p.data$replication %>% as.factor() %>% as.numeric()
xdata = p.data$MTa_pred_MAP
ydata = p.data$PRa_pred_MAP
zdata = p.data$Neurite_Area
xlims = c(0, max(xdata))
ylims = c(0, max(ydata))
zlims = c(0, max(zdata))

open3d()
par3d(windowRect=c(20, 60, 770, 810))
myzoom = 1.2
myexpand = 1.05
my.userMatrix = matrix(
    c(0.86628413, -0.4994070, 0.01201642,    0,
      0.04811093,  0.1073487, 0.99305671,    0,
     -0.49722946, -0.8596911, 0.11702148,    0,
      0.00000000,  0.0000000, 0.00000000,    1), byrow=T, 4, 4)  

par3d(family="sans", cex=1, FOV=30, ignoreExtent=F)

plot3d(x=xdata, y=ydata, z=zdata,
       type="s", # you can set to "n" for a blank plot
       size=1,
       col= rainbow(nrep)[repID],
       xlab="", ylab="", zlab="",
       aspect=c(1,1,1), axes=F, box=F, expand=myexpand,
       xlim=xlims, ylim=ylims, zlim=zlims)

## add bounding box
box3d()  
  axes3d(edges=c('x--', 'y--', 'z-+'))

text3d(x=  xlims[2]/2, y= -ylims[2]/9  , z= -zlims[2]/9  , "MTa_pred_MAP"  , cex=1.4, col="black")
text3d(x= -xlims[2]/6, y=  ylims[2]/2  , z= -zlims[2]/6  , "PRa_pred_MAP"  , cex=1.4, col="black")
text3d(x= -xlims[2]/5, y=  ylims[2]*6/5, z=  zlims[2]/2  , "Neurite_Area"  , cex=1.4, col="black")

rglwidget()
while (rgl.cur() > 0) { rgl.close()}

rm(nrep, repID, xdata, ydata, zdata, xlims, ylims, zlims)
```


### Modelling NRa | MTa, PRa

$$\begin{equation}
\begin{split}
y &= \begin{cases}
y_{max} \left(1 - e^{-k(x - x_{min})} \right) & \text{if $x>x_{min}$} \\
0   & \text{otherwise}
\end{cases}\\
y_{obs} & \sim \mathcal{N}(y, \sigma_{y})
\end{split}
\end{equation}$$

Here

- $y$ : KE of interest : NRa
- $x$ : MTa.

Parameters are 


#### A fit by hand

```{r}
p.data = tmp.data.KE4

p.data$CIa_pred_MAP = log(p.data$concentration_MuMol) %>% 
    f.link.lgstc(.,
                 params = tmp.pars_CIa)

p.data$MTa_pred_MAP = 
  f.link.linear(x = p.data$CIa_pred_MAP,
                params = tmp.pars_MTa) %>% 
  f.link.truncation(., lower = 0, upper = 120) 

```


```{r}
tmp.pars_NRa = list(k         = 0.08,
                    y_max     = 100,
                    x_tox_min = 12)

ggplot(data = p.data,
           aes(x = MTa_pred_MAP,
               y = Neurite_Area)) +
  geom_point(aes(colour = replication)) +
    scale_x_continuous(limit=c(0,120)) +
    scale_y_continuous(limit=c(0,150),oob=squish) +
  stat_function(fun = function(x) {
      f.link.exp_tox_min(x,
                         params = tmp.pars_NRa)
  }) +
  ggtitle("NRa wrt MTa")
```


## Cleanup

```{r}
cleanup()
rm(p.data)
rm(fit_step_by_step_X_CIa_MTa_PRa)
```

----

# Analysis of fit Rotenone

## Load previous fit

```{r include=T, cache = FALSE}
tmp.stanfile.name = "step_by_step_X_CIa_MTa_PRa_NRa"
list.files(glob_params$Stan$FitPath, pattern = tmp.stanfile.name)
f.stanFit.filter.timestamp(pattern = tmp.stanfile.name)
fit_step_by_step_X_CIa_MTa_PRa_NRa =
  readr::read_rds(glob_params$Stan$f.FitPath("step_by_step_X_CIa_MTa_PRa_NRa-timestamp_1907241432-Chain_3-iter_2000-seed_1907241432.stanFit"))
```

## Posterior summary

```{r eval = F}
options(scipen=0, digits=7)
fit_step_by_step_X_CIa_MTa_PRa_NRa
check_hmc_diagnostics(fit_step_by_step_X_CIa_MTa_PRa_NRa)
```


```{r}
tmp.fit = fit_step_by_step_X_CIa_MTa_PRa_NRa

tmp.parsName = c("CIa_min" ,
                 "CIa_max" ,
                 "Par_CIa_50" ,
                 "log_Par_CIa_50",
                 "k_CIa" ,
                 "sigma_CIa",
                 
                 "beta_MTa",
                 "beta_0_MTa",
                 "sigma_MTa",
                 
                 "PRa_min",
                 "PRa_max",
                 "Par_PRa_50",
                 "q_PRa",
                 "sigma_PRa",
                 
                 "k_NRa",
                 "NRa_max",
                 "MTa_tox_min_NRa",
                 "sigma_NRa",

                 "lp__")


la_all = as.data.frame(rstan::extract(tmp.fit, pars = tmp.parsName))

la.map_all = la_all[which.max(la_all$lp__),]


la.summary_all = summary(tmp.fit,
                         probs = c(0.05, 0.95),
                         pars = tmp.parsName)$summary %>% as.data.frame()

la.summary_all$MAP = la.map_all %>% as.matrix() %>% c()
la.mean_all = la.summary_all["mean"] %>% t() %>% as.data.frame()

la.summary_all = la.summary_all %>% select(MAP, mean,se_mean, sd, `5%`, `95%`,n_eff,Rhat)

options("scipen"= 2,digits=2)
# options("scipen"= 0,digits=7)
la.summary_all
```

## Diagnostic {.tabset .tabset-fade .tabset-pills}


### ShinyStan

```{r eval=F, echo=T}
shinystan::launch_shinystan(tmp.fit)
```


### Autocorrelation

```{r}
tmp.parsName

stan_ac(tmp.fit, pars = c("CIa_min",
                          "CIa_max",
                          "Par_CIa_50",
                          "log_Par_CIa_50",
                          "k_CIa",
                          "sigma_CIa",
                          "beta_MTa",
                          "beta_0_MTa",
                          "sigma_MTa",
                          "Par_PRa_50",
                          "q_PRa",
                          "sigma_PRa",
                          "k_NRa",
                          "NRa_max",
                          "MTa_tox_min_NRa"))
```


### Traceplots{.tabset .tabset-fade .tabset-pills}


```{r}
posterior2 <- rstan::extract(tmp.fit, 
                             # inc_warmup = TRUE, 
                             permuted = FALSE)
color_scheme_set("mix-blue-pink")
```

#### CIa

```{r}
p <- mcmc_trace(posterior2,  
                pars =  c("CIa_min" ,
                 "CIa_max" ,
                 "Par_CIa_50" ,
                 "log_Par_CIa_50",
                 "k_CIa" ,
                 "sigma_CIa"),
                # n_warmup = dim(posterior2)[1]/2 %>% floor(),
                facet_args = list(nrow = 2, labeller = label_parsed))
p + facet_text(size = 15)
```

#### MTa

```{r}
p <- mcmc_trace(posterior2,  
                pars =  c("beta_MTa",
                          "beta_0_MTa",
                          "sigma_MTa"),
                # n_warmup = dim(posterior2)[1]/2 %>% floor(),
                facet_args = list(nrow = 2, labeller = label_parsed))
p + facet_text(size = 15)
```

#### PRa

**PRa_min** and **PRa_max** are preset to be $0$. 

```{r}
p <- mcmc_trace(posterior2,  
                pars =  c("PRa_min",
                 "PRa_max",
                 "Par_PRa_50",
                 "q_PRa",
                 "sigma_PRa"),
                # n_warmup = dim(posterior2)[1]/2 %>% floor(),
                facet_args = list(nrow = 2, labeller = label_parsed))
p + facet_text(size = 15)
```

#### NRa

```{r}
p <- mcmc_trace(posterior2,  
                pars =  c(
                 "k_NRa",
                 "NRa_max",
                 "MTa_tox_min_NRa",
                 "sigma_NRa"),
                # n_warmup = dim(posterior2)[1]/2 %>% floor(),
                facet_args = list(nrow = 2, labeller = label_parsed))
p + facet_text(size = 15)
```

```{r echo=F}
rm(posterior2)
```



## Visual validation {.tabset .tabset-fade .tabset-pills}

**Linking functions**

```{r eval = F, code = readLines(glob_params$f.RScript("CPDs.R"))}
```

```{r include=F}
source(glob_params$f.RScript("CPDs.R"))
source(glob_params$f.RScript('load-and-reshape-Konstanz-data.R'))
tmp.chemi = "Rotenone"
tmp.data.KE1 = KE1.both %>% filter(., chemi == tmp.chemi, concentration_MuMol > 0)
tmp.data.KE2 = KE2.both %>% filter(., chemi == tmp.chemi, concentration_MuMol > 0)
tmp.data.KE3 = KE3.both %>% filter(., chemi == tmp.chemi, concentration_MuMol > 0)
tmp.data.KE4 = KE4.both %>% filter(., chemi == tmp.chemi, concentration_MuMol > 0)
```

### X->CIa {.tabset .tabset-fade .tabset-pills}

#### Prediction with MAP

**Maximum _a posteriori_**

```{r}
options("scipen"= 6, digits=2)
tmp.est.ponct = la.map_all
# tmp.est.ponct = la.mean_all ; la.mean_all %>% t()

# Parameters of stanFit for CIa
tmp.pars_CIa = list(y_min     = tmp.est.ponct$CIa_min,
                    y_max     = tmp.est.ponct$CIa_max,
                    x_50      = tmp.est.ponct$log_Par_CIa_50,
                    k         = tmp.est.ponct$k_CIa)
```

```{r}
p = ggplot(data = tmp.data.KE1,
           aes(x = concentration_MuMol,
               y = c1_activity))

p +
  geom_point(aes(colour = replication)) +
  scale_y_continuous(limit=c(0,NA),oob=squish) +
  scale_x_continuous(trans = "log10") +
  stat_function(fun = function(x) f.link.lgstc(log(x),
                                               params = tmp.pars_CIa))
```

#### Prediction with Post-Mean

**Posterior Mean**

```{r}
options("scipen"= 6, digits=2)
tmp.est.ponct = la.mean_all

# Parameters of stanFit for CIa
tmp.pars_CIa = list(y_min     = tmp.est.ponct$CIa_min,
                    y_max     = tmp.est.ponct$CIa_max,
                    x_50      = tmp.est.ponct$log_Par_CIa_50,
                    k         = tmp.est.ponct$k_CIa)
```

```{r}
p = ggplot(data = tmp.data.KE1,
           aes(x = concentration_MuMol,
               y = c1_activity))

p +
  geom_point(aes(colour = replication)) +
  scale_y_continuous(limit=c(0,NA),oob=squish) +
  scale_x_continuous(trans = "log10") +
  stat_function(fun = function(x) f.link.lgstc(log(x),
                                               params = tmp.pars_CIa))
```

<!-- #### Predictive Posterior with MAP curve -->

<!-- ```{r eval} -->
<!-- names(tmp.fit) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- tmp.CIa_pp <- rstan::extract(tmp.fit, "CIa_pred_CIa") %>% -->
<!--   reshape2::melt() -->

<!-- tmp.concentration_MuMol = data.frame( -->
<!--                             concentration_MuMol = tmp.data.KE1$concentration_MuMol, -->
<!--                             Var2 = 1:12) -->

<!-- tmp.CIa_pp = left_join(tmp.CIa_pp, tmp.concentration_MuMol, by = "Var2") -->
<!-- ``` -->



<!-- ```{r} -->
<!-- tmp.CIa_pp %>% -->
<!--   ggplot() + -->
<!--   geom_point(aes(x = concentration_MuMol, y = value, group = Var2), colour = "orange", alpha = 0.1, adjust = .8) + -->
<!--   geom_point(data = tmp.data.KE1, -->
<!--            aes(x = concentration_MuMol, -->
<!--                y = c1_activity, colour = replication)) + -->
<!--   scale_y_continuous(limit=c(-5, NA),oob=squish) + -->
<!--   scale_x_continuous(trans = "log10") + -->
<!--   stat_function(fun = function(x) f.link.lgstc(log(x), -->
<!--                                                params = tmp.pars_CIa)) + -->
<!--   ggtitle("Actual CIa and posterior predictive replications wrt Dose") + -->
<!--   annotate("text", x = 0.05, y = 80, label = "MAP prediction curve", hjust = 0) + -->
<!--   annotate("text", x = 0.05, y = 60, label = "Posterior replications", colour = "orange", hjust = 0) -->
<!-- ``` -->


### CIa -> MTa {.tabset .tabset-fade .tabset-pills}

#### Prediction with MAP

**Maximum _a posteriori_**

```{r}
options("scipen"= 6, digits=2)
tmp.est.ponct = la.map_all
# tmp.est.ponct = la.mean_all

# Parameters of stanFit for CIa
tmp.pars_CIa = list(y_min     = tmp.est.ponct$CIa_min,
                    y_max     = tmp.est.ponct$CIa_max,
                    x_50      = tmp.est.ponct$log_Par_CIa_50,
                    k         = tmp.est.ponct$k_CIa)
tmp.pars_MTa = list(beta     = tmp.est.ponct$beta_MTa,
                    beta_0   = tmp.est.ponct$beta_0_MTa)
```

```{r}
p = ggplot(data = tmp.data.KE2,
           aes(x = f.link.lgstc(log(concentration_MuMol), params = tmp.pars_CIa),
               y = mito_resp))

p +
  geom_point(aes(colour = replication)) +
  scale_x_continuous(limit=c(0,NA),oob=squish) +
  scale_y_continuous(limit=c(0,NA),oob=squish) +
  stat_function(fun = function(x)
    f.link.linear(x,
                  params = tmp.pars_MTa) %>%
      f.link.truncation(., lower = 0, upper = 120))

```


#### Prediction with Post-Mean

**Posterior Mean**

```{r}
options("scipen"= 6, digits=2)
tmp.est.ponct = la.mean_all

# Parameters of stanFit for CIa
tmp.pars_CIa = list(y_min     = tmp.est.ponct$CIa_min,
                    y_max     = tmp.est.ponct$CIa_max,
                    x_50      = tmp.est.ponct$log_Par_CIa_50,
                    k         = tmp.est.ponct$k_CIa)
tmp.pars_MTa = list(beta     = tmp.est.ponct$beta_MTa,
                    beta_0   = tmp.est.ponct$beta_0_MTa)
```

```{r}
p = ggplot(data = tmp.data.KE2,
           aes(x = f.link.lgstc(log(concentration_MuMol), params = tmp.pars_CIa),
               y = mito_resp))

p +
  geom_point(aes(colour = replication)) +
  scale_x_continuous(limit=c(0,NA),oob=squish) +
  scale_y_continuous(limit=c(0,NA),oob=squish) +
  stat_function(fun = function(x)
    f.link.linear(x,
                  params = tmp.pars_MTa) %>%
      f.link.truncation(., lower = 0, upper = 120))

```


### MTa -> PRa {.tabset .tabset-fade .tabset-pills}

#### Prediction with MAP

**Maximum _a posteriori_**

```{r}
options("scipen"= 6, digits=2)
tmp.est.ponct = la.map_all
# tmp.est.ponct = la.mean_all

# Parameters of stanFit for CIa
tmp.pars_CIa = list(y_min     = tmp.est.ponct$CIa_min,
                    y_max     = tmp.est.ponct$CIa_max,
                    x_50      = tmp.est.ponct$log_Par_CIa_50,
                    k         = tmp.est.ponct$k_CIa)
tmp.pars_MTa = list(beta     = tmp.est.ponct$beta_MTa,
                    beta_0   = tmp.est.ponct$beta_0_MTa)
tmp.pars_PRa = list(y_min     = tmp.est.ponct$PRa_min,
                    y_max     = tmp.est.ponct$PRa_max,
                    x_50      = tmp.est.ponct$Par_PRa_50,
                    k         = exp(tmp.est.ponct$q_PRa) )
```

```{r}
p.data = tmp.data.KE3

p.data$CIa_pred_MAP = log(p.data$concentration_MuMol) %>% 
    f.link.lgstc(.,
                 params = tmp.pars_CIa)

p.data$MTa_pred_MAP = 
  f.link.linear(x = p.data$CIa_pred_MAP,
                params = tmp.pars_MTa) %>% 
  f.link.truncation(., lower = 0, upper = 120) 

ggplot(data = p.data,
           aes(x = MTa_pred_MAP,
               y = Prot_acti)) +
  geom_point(aes(colour = replication)) +
    scale_x_continuous(limit=c(0,120)) +
    scale_y_continuous(limit=c(0,150),oob=squish) +
  stat_function(fun = function(x) 
    f.link.lgstc(x,
                 params = tmp.pars_PRa))

```


#### Prediction with Post-Mean

**Posterior Mean**

```{r}
options("scipen"= 6, digits=2)
tmp.est.ponct = la.mean_all

# Parameters of stanFit for CIa
tmp.pars_CIa = list(y_min     = tmp.est.ponct$CIa_min,
                    y_max     = tmp.est.ponct$CIa_max,
                    x_50      = tmp.est.ponct$log_Par_CIa_50,
                    k         = tmp.est.ponct$k_CIa)
tmp.pars_MTa = list(beta     = tmp.est.ponct$beta_MTa,
                    beta_0   = tmp.est.ponct$beta_0_MTa)
tmp.pars_PRa = list(y_min     = tmp.est.ponct$PRa_min,
                    y_max     = tmp.est.ponct$PRa_max,
                    x_50      = tmp.est.ponct$Par_PRa_50,
                    k         = exp(tmp.est.ponct$q_PRa) )
```

```{r}
p.data = tmp.data.KE3

p.data$CIa_pred_MAP = log(p.data$concentration_MuMol) %>% 
    f.link.lgstc(.,
                 params = tmp.pars_CIa)

p.data$MTa_pred_MAP = 
  f.link.linear(x = p.data$CIa_pred_MAP,
                params = tmp.pars_MTa) %>% 
  f.link.truncation(., lower = 0, upper = 120) 

ggplot(data = p.data,
           aes(x = MTa_pred_MAP,
               y = Prot_acti)) +
  geom_point(aes(colour = replication)) +
    scale_x_continuous(limit=c(0,120)) +
    scale_y_continuous(limit=c(0,150),oob=squish) +
  stat_function(fun = function(x) 
    f.link.lgstc(x,
                 params = tmp.pars_PRa))

```


### MTa -> PRa {.tabset .tabset-fade .tabset-pills}

#### Prediction with MAP

**Maximum _a posteriori_**

```{r}
options("scipen"= 6, digits=2)
tmp.est.ponct = la.map_all
# tmp.est.ponct = la.mean_all

# Parameters of stanFit for CIa
tmp.pars_CIa = list(y_min     = tmp.est.ponct$CIa_min,
                    y_max     = tmp.est.ponct$CIa_max,
                    x_50      = tmp.est.ponct$log_Par_CIa_50,
                    k         = tmp.est.ponct$k_CIa)

tmp.pars_MTa = list(beta     = tmp.est.ponct$beta_MTa,
                    beta_0   = tmp.est.ponct$beta_0_MTa)

tmp.pars_PRa = list(y_min     = tmp.est.ponct$PRa_min,
                    y_max     = tmp.est.ponct$PRa_max,
                    x_50      = tmp.est.ponct$Par_PRa_50,
                    k         = exp(tmp.est.ponct$q_PRa) )

tmp.pars_NRa = list(k         = tmp.est.ponct$k_NRa,
                    y_max     = tmp.est.ponct$NRa_max,
                    x_tox_min = tmp.est.ponct$MTa_tox_min_NRa)

```

```{r}
p.data = tmp.data.KE4

p.data$CIa_pred_MAP = log(p.data$concentration_MuMol) %>% 
    f.link.lgstc(.,
                 params = tmp.pars_CIa)

p.data$MTa_pred_MAP = 
  f.link.linear(x = p.data$CIa_pred_MAP,
                params = tmp.pars_MTa) %>% 
  f.link.truncation(., lower = 0, upper = 120) 

p.data$NRa_pred_MAP = 
  f.link.exp_tox_min(x = p.data$MTa_pred_MAP,
                     params = tmp.pars_NRa)

ggplot(data = p.data,
           aes(x = MTa_pred_MAP,
               y = Neurite_Area)) +
  geom_point(aes(colour = replication)) +
    scale_x_continuous(limit=c(0,120)) +
    scale_y_continuous(limit=c(0,150),oob=squish) +
  stat_function(fun = function(x) 
    f.link.exp_tox_min(x,
                 params = tmp.pars_NRa))
```




#### Prediction with Post-mean

**Maximum _a posteriori_**

```{r}
tmp.est.ponct = la.mean_all
# tmp.est.ponct = la.mean_all

# Parameters of stanFit for CIa
tmp.pars_CIa = list(y_min     = tmp.est.ponct$CIa_min,
                    y_max     = tmp.est.ponct$CIa_max,
                    x_50      = tmp.est.ponct$log_Par_CIa_50,
                    k         = tmp.est.ponct$k_CIa)

tmp.pars_MTa = list(beta     = tmp.est.ponct$beta_MTa,
                    beta_0   = tmp.est.ponct$beta_0_MTa)

tmp.pars_PRa = list(y_min     = tmp.est.ponct$PRa_min,
                    y_max     = tmp.est.ponct$PRa_max,
                    x_50      = tmp.est.ponct$Par_PRa_50,
                    k         = exp(tmp.est.ponct$q_PRa) )

tmp.pars_NRa = list(k         = tmp.est.ponct$k_NRa,
                    y_max     = tmp.est.ponct$NRa_max,
                    x_tox_min = tmp.est.ponct$MTa_tox_min_NRa)

```

```{r}
p.data = tmp.data.KE4

p.data$CIa_pred_MAP = log(p.data$concentration_MuMol) %>% 
    f.link.lgstc(.,
                 params = tmp.pars_CIa)

p.data$MTa_pred_MAP = 
  f.link.linear(x = p.data$CIa_pred_MAP,
                params = tmp.pars_MTa) %>% 
  f.link.truncation(., lower = 0, upper = 120) 

p.data$NRa_pred_MAP = 
  f.link.exp_tox_min(x = p.data$MTa_pred_MAP,
                     params = tmp.pars_NRa)

ggplot(data = p.data,
           aes(x = MTa_pred_MAP,
               y = Neurite_Area)) +
  geom_point(aes(colour = replication)) +
    scale_x_continuous(limit=c(0,120)) +
    scale_y_continuous(limit=c(0,150),oob=squish) +
  stat_function(fun = function(x) 
    f.link.exp_tox_min(x,
                 params = tmp.pars_NRa))
```


# Analysis of fit Deguelin

## Load previous fit

```{r include=T, cache = FALSE}
tmp.chemi = "Deguelin"
tmp.stanfile.name = "step_by_step_X_CIa_MTa_PRa_NRa"
intersect(list.files(glob_params$Stan$FitPath, pattern = tmp.stanfile.name),
          list.files(glob_params$Stan$FitPath, pattern = tmp.chemi))

f.stanFit.filter.timestamp(pattern = c(tmp.chemi))
fit_step_by_step_X_CIa_MTa_PRa_NRa =
  readr::read_rds(glob_params$Stan$f.FitPath("step_by_step_X_CIa_MTa_PRa_NRa-chemi_Deguelin-timestamp_1907241700-Chain_3-iter_8000-seed_1907241700.stanFit"))
```

## Posterior summary

```{r eval = F}
options(scipen=0, digits=7)
fit_step_by_step_X_CIa_MTa_PRa_NRa
check_hmc_diagnostics(fit_step_by_step_X_CIa_MTa_PRa_NRa)
```


```{r}
tmp.fit = fit_step_by_step_X_CIa_MTa_PRa_NRa

tmp.parsName = c("CIa_min" ,
                 "CIa_max" ,
                 "Par_CIa_50" ,
                 "log_Par_CIa_50",
                 "k_CIa" ,
                 "sigma_CIa",
                 
                 "beta_MTa",
                 "beta_0_MTa",
                 "sigma_MTa",
                 
                 "PRa_min",
                 "PRa_max",
                 "Par_PRa_50",
                 "q_PRa",
                 "sigma_PRa",
                 
                 "k_NRa",
                 "NRa_max",
                 "MTa_tox_min_NRa",
                 "sigma_NRa",

                 "lp__")


la_all = as.data.frame(rstan::extract(tmp.fit, pars = tmp.parsName))

la.map_all = la_all[which.max(la_all$lp__),]


la.summary_all = summary(tmp.fit,
                         probs = c(0.05, 0.95),
                         pars = tmp.parsName)$summary %>% as.data.frame()

la.summary_all$MAP = la.map_all %>% as.matrix() %>% c()
la.mean_all = la.summary_all["mean"] %>% t() %>% as.data.frame()

la.summary_all = la.summary_all %>% select(MAP, mean,se_mean, sd, `5%`, `95%`,n_eff,Rhat)

options("scipen"= 2,digits=2)
# options("scipen"= 0,digits=7)
la.summary_all
```

## Diagnostic {.tabset .tabset-fade .tabset-pills}


### ShinyStan

```{r eval=F, echo=T}
shinystan::launch_shinystan(tmp.fit)
```


### Autocorrelation

```{r}
tmp.parsName

stan_ac(tmp.fit, pars = c("CIa_min",
                          "CIa_max",
                          "Par_CIa_50",
                          "log_Par_CIa_50",
                          "k_CIa",
                          "sigma_CIa",
                          "beta_MTa",
                          "beta_0_MTa",
                          "sigma_MTa",
                          "Par_PRa_50",
                          "q_PRa",
                          "sigma_PRa",
                          "k_NRa",
                          "NRa_max",
                          "MTa_tox_min_NRa"))
```


### Traceplots{.tabset .tabset-fade .tabset-pills}


```{r}
posterior2 <- rstan::extract(tmp.fit, 
                             # inc_warmup = TRUE, 
                             permuted = FALSE)
color_scheme_set("mix-blue-pink")
```

#### CIa

```{r}
p <- mcmc_trace(posterior2,  
                pars =  c("CIa_min" ,
                 "CIa_max" ,
                 "Par_CIa_50" ,
                 "log_Par_CIa_50",
                 "k_CIa" ,
                 "sigma_CIa"),
                # n_warmup = dim(posterior2)[1]/2 %>% floor(),
                facet_args = list(nrow = 2, labeller = label_parsed))
p + facet_text(size = 15)
```

#### MTa

```{r}
p <- mcmc_trace(posterior2,  
                pars =  c("beta_MTa",
                          "beta_0_MTa",
                          "sigma_MTa"),
                # n_warmup = dim(posterior2)[1]/2 %>% floor(),
                facet_args = list(nrow = 2, labeller = label_parsed))
p + facet_text(size = 15)
```

#### PRa

**PRa_min** and **PRa_max** are preset to be $0$. 

```{r}
p <- mcmc_trace(posterior2,  
                pars =  c("PRa_min",
                 "PRa_max",
                 "Par_PRa_50",
                 "q_PRa",
                 "sigma_PRa"),
                # n_warmup = dim(posterior2)[1]/2 %>% floor(),
                facet_args = list(nrow = 2, labeller = label_parsed))
p + facet_text(size = 15)
```

#### NRa

```{r}
p <- mcmc_trace(posterior2,  
                pars =  c(
                 "k_NRa",
                 "NRa_max",
                 "MTa_tox_min_NRa",
                 "sigma_NRa"),
                # n_warmup = dim(posterior2)[1]/2 %>% floor(),
                facet_args = list(nrow = 2, labeller = label_parsed))
p + facet_text(size = 15)
```

```{r echo=F}
rm(posterior2)
```



## Visual validation {.tabset .tabset-fade .tabset-pills}

**Linking functions**

```{r eval = F, code = readLines(glob_params$f.RScript("CPDs.R"))}
```

```{r include=F}
source(glob_params$f.RScript("CPDs.R"))
source(glob_params$f.RScript('load-and-reshape-Konstanz-data.R'))
tmp.chemi = "Deguelin"
tmp.data.KE1 = KE1.both %>% filter(., chemi == tmp.chemi, concentration_MuMol > 0)
tmp.data.KE2 = KE2.both %>% filter(., chemi == tmp.chemi, concentration_MuMol > 0)
tmp.data.KE3 = KE3.both %>% filter(., chemi == tmp.chemi, concentration_MuMol > 0)
tmp.data.KE4 = KE4.both %>% filter(., chemi == tmp.chemi, concentration_MuMol > 0)
```

### X->CIa {.tabset .tabset-fade .tabset-pills}

#### Prediction with MAP

**Maximum _a posteriori_**

```{r}
options("scipen"= 6, digits=2)
tmp.est.ponct = la.map_all
# tmp.est.ponct = la.mean_all ; la.mean_all %>% t()

# Parameters of stanFit for CIa
tmp.pars_CIa = list(y_min     = tmp.est.ponct$CIa_min,
                    y_max     = tmp.est.ponct$CIa_max,
                    x_50      = tmp.est.ponct$log_Par_CIa_50,
                    k         = tmp.est.ponct$k_CIa)
```

```{r}
p = ggplot(data = tmp.data.KE1,
           aes(x = concentration_MuMol,
               y = c1_activity))

p +
  geom_point(aes(colour = replication)) +
  scale_y_continuous(limit=c(0,NA),oob=squish) +
  scale_x_continuous(trans = "log10") +
  stat_function(fun = function(x) f.link.lgstc(log(x),
                                               params = tmp.pars_CIa))
```

#### Prediction with Post-Mean

**Posterior Mean**

```{r}
options("scipen"= 6, digits=2)
tmp.est.ponct = la.mean_all

# Parameters of stanFit for CIa
tmp.pars_CIa = list(y_min     = tmp.est.ponct$CIa_min,
                    y_max     = tmp.est.ponct$CIa_max,
                    x_50      = tmp.est.ponct$log_Par_CIa_50,
                    k         = tmp.est.ponct$k_CIa)
```

```{r}
p = ggplot(data = tmp.data.KE1,
           aes(x = concentration_MuMol,
               y = c1_activity))

p +
  geom_point(aes(colour = replication)) +
  scale_y_continuous(limit=c(0,NA),oob=squish) +
  scale_x_continuous(trans = "log10") +
  stat_function(fun = function(x) f.link.lgstc(log(x),
                                               params = tmp.pars_CIa))
```

<!-- #### Predictive Posterior with MAP curve -->

<!-- ```{r eval} -->
<!-- names(tmp.fit) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- tmp.CIa_pp <- rstan::extract(tmp.fit, "CIa_pred_CIa") %>% -->
<!--   reshape2::melt() -->

<!-- tmp.concentration_MuMol = data.frame( -->
<!--                             concentration_MuMol = tmp.data.KE1$concentration_MuMol, -->
<!--                             Var2 = 1:12) -->

<!-- tmp.CIa_pp = left_join(tmp.CIa_pp, tmp.concentration_MuMol, by = "Var2") -->
<!-- ``` -->



<!-- ```{r} -->
<!-- tmp.CIa_pp %>% -->
<!--   ggplot() + -->
<!--   geom_point(aes(x = concentration_MuMol, y = value, group = Var2), colour = "orange", alpha = 0.1, adjust = .8) + -->
<!--   geom_point(data = tmp.data.KE1, -->
<!--            aes(x = concentration_MuMol, -->
<!--                y = c1_activity, colour = replication)) + -->
<!--   scale_y_continuous(limit=c(-5, NA),oob=squish) + -->
<!--   scale_x_continuous(trans = "log10") + -->
<!--   stat_function(fun = function(x) f.link.lgstc(log(x), -->
<!--                                                params = tmp.pars_CIa)) + -->
<!--   ggtitle("Actual CIa and posterior predictive replications wrt Dose") + -->
<!--   annotate("text", x = 0.05, y = 80, label = "MAP prediction curve", hjust = 0) + -->
<!--   annotate("text", x = 0.05, y = 60, label = "Posterior replications", colour = "orange", hjust = 0) -->
<!-- ``` -->


### CIa -> MTa {.tabset .tabset-fade .tabset-pills}

#### Prediction with MAP

**Maximum _a posteriori_**

```{r}
options("scipen"= 6, digits=2)
tmp.est.ponct = la.map_all
# tmp.est.ponct = la.mean_all

# Parameters of stanFit for CIa
tmp.pars_CIa = list(y_min     = tmp.est.ponct$CIa_min,
                    y_max     = tmp.est.ponct$CIa_max,
                    x_50      = tmp.est.ponct$log_Par_CIa_50,
                    k         = tmp.est.ponct$k_CIa)
tmp.pars_MTa = list(beta     = tmp.est.ponct$beta_MTa,
                    beta_0   = tmp.est.ponct$beta_0_MTa)
```

```{r}
p = ggplot(data = tmp.data.KE2,
           aes(x = f.link.lgstc(log(concentration_MuMol), params = tmp.pars_CIa),
               y = mito_resp))

p +
  geom_point(aes(colour = replication)) +
  scale_x_continuous(limit=c(0,NA),oob=squish) +
  scale_y_continuous(limit=c(0,NA),oob=squish) +
  stat_function(fun = function(x)
    f.link.linear(x,
                  params = tmp.pars_MTa) %>%
      f.link.truncation(., lower = 0, upper = 120))

```


#### Prediction with Post-Mean

**Posterior Mean**

```{r}
options("scipen"= 6, digits=2)
tmp.est.ponct = la.mean_all

# Parameters of stanFit for CIa
tmp.pars_CIa = list(y_min     = tmp.est.ponct$CIa_min,
                    y_max     = tmp.est.ponct$CIa_max,
                    x_50      = tmp.est.ponct$log_Par_CIa_50,
                    k         = tmp.est.ponct$k_CIa)
tmp.pars_MTa = list(beta     = tmp.est.ponct$beta_MTa,
                    beta_0   = tmp.est.ponct$beta_0_MTa)
```

```{r}
p = ggplot(data = tmp.data.KE2,
           aes(x = f.link.lgstc(log(concentration_MuMol), params = tmp.pars_CIa),
               y = mito_resp))

p +
  geom_point(aes(colour = replication)) +
  scale_x_continuous(limit=c(0,NA),oob=squish) +
  scale_y_continuous(limit=c(0,NA),oob=squish) +
  stat_function(fun = function(x)
    f.link.linear(x,
                  params = tmp.pars_MTa) %>%
      f.link.truncation(., lower = 0, upper = 120))

```


### MTa -> PRa {.tabset .tabset-fade .tabset-pills}

#### Prediction with MAP

**Maximum _a posteriori_**

```{r}
options("scipen"= 6, digits=2)
tmp.est.ponct = la.map_all
# tmp.est.ponct = la.mean_all

# Parameters of stanFit for CIa
tmp.pars_CIa = list(y_min     = tmp.est.ponct$CIa_min,
                    y_max     = tmp.est.ponct$CIa_max,
                    x_50      = tmp.est.ponct$log_Par_CIa_50,
                    k         = tmp.est.ponct$k_CIa)
tmp.pars_MTa = list(beta     = tmp.est.ponct$beta_MTa,
                    beta_0   = tmp.est.ponct$beta_0_MTa)
tmp.pars_PRa = list(y_min     = tmp.est.ponct$PRa_min,
                    y_max     = tmp.est.ponct$PRa_max,
                    x_50      = tmp.est.ponct$Par_PRa_50,
                    k         = exp(tmp.est.ponct$q_PRa) )
```

```{r}
p.data = tmp.data.KE3

p.data$CIa_pred_MAP = log(p.data$concentration_MuMol) %>% 
    f.link.lgstc(.,
                 params = tmp.pars_CIa)

p.data$MTa_pred_MAP = 
  f.link.linear(x = p.data$CIa_pred_MAP,
                params = tmp.pars_MTa) %>% 
  f.link.truncation(., lower = 0, upper = 120) 

ggplot(data = p.data,
           aes(x = MTa_pred_MAP,
               y = Prot_acti)) +
  geom_point(aes(colour = replication)) +
    scale_x_continuous(limit=c(0,120)) +
    scale_y_continuous(limit=c(0,150),oob=squish) +
  stat_function(fun = function(x) 
    f.link.lgstc(x,
                 params = tmp.pars_PRa))

```


#### Prediction with Post-Mean

**Posterior Mean**

```{r}
options("scipen"= 6, digits=2)
tmp.est.ponct = la.mean_all

# Parameters of stanFit for CIa
tmp.pars_CIa = list(y_min     = tmp.est.ponct$CIa_min,
                    y_max     = tmp.est.ponct$CIa_max,
                    x_50      = tmp.est.ponct$log_Par_CIa_50,
                    k         = tmp.est.ponct$k_CIa)
tmp.pars_MTa = list(beta     = tmp.est.ponct$beta_MTa,
                    beta_0   = tmp.est.ponct$beta_0_MTa)
tmp.pars_PRa = list(y_min     = tmp.est.ponct$PRa_min,
                    y_max     = tmp.est.ponct$PRa_max,
                    x_50      = tmp.est.ponct$Par_PRa_50,
                    k         = exp(tmp.est.ponct$q_PRa) )
```

```{r}
p.data = tmp.data.KE3

p.data$CIa_pred_MAP = log(p.data$concentration_MuMol) %>% 
    f.link.lgstc(.,
                 params = tmp.pars_CIa)

p.data$MTa_pred_MAP = 
  f.link.linear(x = p.data$CIa_pred_MAP,
                params = tmp.pars_MTa) %>% 
  f.link.truncation(., lower = 0, upper = 120) 

ggplot(data = p.data,
           aes(x = MTa_pred_MAP,
               y = Prot_acti)) +
  geom_point(aes(colour = replication)) +
    scale_x_continuous(limit=c(0,120)) +
    scale_y_continuous(limit=c(0,150),oob=squish) +
  stat_function(fun = function(x) 
    f.link.lgstc(x,
                 params = tmp.pars_PRa))

```


### MTa -> PRa {.tabset .tabset-fade .tabset-pills}

#### Prediction with MAP

**Maximum _a posteriori_**

```{r}
options("scipen"= 6, digits=2)
tmp.est.ponct = la.map_all
# tmp.est.ponct = la.mean_all

# Parameters of stanFit for CIa
tmp.pars_CIa = list(y_min     = tmp.est.ponct$CIa_min,
                    y_max     = tmp.est.ponct$CIa_max,
                    x_50      = tmp.est.ponct$log_Par_CIa_50,
                    k         = tmp.est.ponct$k_CIa)

tmp.pars_MTa = list(beta     = tmp.est.ponct$beta_MTa,
                    beta_0   = tmp.est.ponct$beta_0_MTa)

tmp.pars_PRa = list(y_min     = tmp.est.ponct$PRa_min,
                    y_max     = tmp.est.ponct$PRa_max,
                    x_50      = tmp.est.ponct$Par_PRa_50,
                    k         = exp(tmp.est.ponct$q_PRa) )

tmp.pars_NRa = list(k         = tmp.est.ponct$k_NRa,
                    y_max     = tmp.est.ponct$NRa_max,
                    x_tox_min = tmp.est.ponct$MTa_tox_min_NRa)

```

```{r}
p.data = tmp.data.KE4

p.data$CIa_pred_MAP = log(p.data$concentration_MuMol) %>% 
    f.link.lgstc(.,
                 params = tmp.pars_CIa)

p.data$MTa_pred_MAP = 
  f.link.linear(x = p.data$CIa_pred_MAP,
                params = tmp.pars_MTa) %>% 
  f.link.truncation(., lower = 0, upper = 120) 

p.data$NRa_pred_MAP = 
  f.link.exp_tox_min(x = p.data$MTa_pred_MAP,
                     params = tmp.pars_NRa)

ggplot(data = p.data,
           aes(x = MTa_pred_MAP,
               y = Neurite_Area)) +
  geom_point(aes(colour = replication)) +
    scale_x_continuous(limit=c(0,120)) +
    scale_y_continuous(limit=c(0,150),oob=squish) +
  stat_function(fun = function(x) 
    f.link.exp_tox_min(x,
                 params = tmp.pars_NRa))
```




#### Prediction with Post-mean

**Maximum _a posteriori_**

```{r}
tmp.est.ponct = la.mean_all
# tmp.est.ponct = la.mean_all

# Parameters of stanFit for CIa
tmp.pars_CIa = list(y_min     = tmp.est.ponct$CIa_min,
                    y_max     = tmp.est.ponct$CIa_max,
                    x_50      = tmp.est.ponct$log_Par_CIa_50,
                    k         = tmp.est.ponct$k_CIa)

tmp.pars_MTa = list(beta     = tmp.est.ponct$beta_MTa,
                    beta_0   = tmp.est.ponct$beta_0_MTa)

tmp.pars_PRa = list(y_min     = tmp.est.ponct$PRa_min,
                    y_max     = tmp.est.ponct$PRa_max,
                    x_50      = tmp.est.ponct$Par_PRa_50,
                    k         = exp(tmp.est.ponct$q_PRa) )

tmp.pars_NRa = list(k         = tmp.est.ponct$k_NRa,
                    y_max     = tmp.est.ponct$NRa_max,
                    x_tox_min = tmp.est.ponct$MTa_tox_min_NRa)

```

```{r}
p.data = tmp.data.KE4

p.data$CIa_pred_MAP = log(p.data$concentration_MuMol) %>% 
    f.link.lgstc(.,
                 params = tmp.pars_CIa)

p.data$MTa_pred_MAP = 
  f.link.linear(x = p.data$CIa_pred_MAP,
                params = tmp.pars_MTa) %>% 
  f.link.truncation(., lower = 0, upper = 120) 

p.data$NRa_pred_MAP = 
  f.link.exp_tox_min(x = p.data$MTa_pred_MAP,
                     params = tmp.pars_NRa)

ggplot(data = p.data,
           aes(x = MTa_pred_MAP,
               y = Neurite_Area)) +
  geom_point(aes(colour = replication)) +
    scale_x_continuous(limit=c(0,120)) +
    scale_y_continuous(limit=c(0,150),oob=squish) +
  stat_function(fun = function(x) 
    f.link.exp_tox_min(x,
                 params = tmp.pars_NRa))
```