---
title: "step_by_step_uptoKE3_PRa_Hierarchical_Exp"
output:
  html_document:
    toc: true
    toc_depth: 3
    code_folding: hide
    number_sections: true
    toc_float:
      collapsed: false
      smooth_scroll: false
    fig_caption: true
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = '..')
knitr::opts_chunk$set(
  cache = FALSE,
  out.width = "100%",
  fig.align = 'center',
  fig.width = 8,
  fig.asp = 0.618,  # 1 / phi
  fig.show = "hold",
  warning=FALSE, message=FALSE,
  eval = TRUE, echo = TRUE
)
```

```{r include=F}
file.copy("./img", "./Rnotebook", recursive=TRUE, overwrite=T)
```


```{r include=FALSE}
source("GlobalParameters.R")
source(glob_params$f.RFunc("stanFit_Name.R"))
pckToLoad = c('tidyverse', 'DT',  "threejs",
              "plyr","citr","readxl",'scales',"rstan","reshape2", "rgl",
              "bayesplot","gridExtra")
reloadpck()
```


Modelling qAOP using DBN

# AOP ETR07N

```{r echo=FALSE, out.width='100%'}
knitr::include_graphics('./img/AOP_ETR07N.png')
```

- Chemical : `Dose` for chemical concentration
- KE1 : `CIa` for complex I activity
- KE2 : `MTa` for Mitochondrial activity
- KE3 : `PRa` for proteostasis activity
- KE4 : `NRa` for Neurite Area

# Model description

Let's implement user specified linkind function for each Key event relationship.

## X -> CIa : Log-logistic

$$\begin{equation}
\begin{split}
y &= \frac{y_{max} - y_{min}}{1 + e^{-k\left(\ln(x) - \ln(x_{50}) \right)}} + y_{min}\\
y_{obs} &\sim \mathcal{N}(y, \sigma_{y}^2)
\end{split}
\end{equation}$$

Here

- $y$ : KE of interest : CIa
- $x$ : Parent node of $y$ in the AOP : Dose
- $x_{50}$ : the center of symmetry of the logistic (transformed $tanh()$) function.

## CIa -> MTa : truncated Linear

### Modelling CIa -> MTa

$$\begin{equation}
\begin{split}
y_{tmp} &= \beta x + \beta_{0} \\
y &= \begin{cases}
120 & \text{if $y_{tmp}>120$} \\
0   & \text{if $y_{tmp}<0$}   \\
y_{tmp} & \text{otherwise}
\end{cases}\\
y_{obs} &\sim \mathcal{N}(y, \sigma_{y}^2)
\end{split}
\end{equation}$$

Here

- $y$ : KE of interest : MTa
- $x$ : Parent node of $y$ in the AOP.

## MTa -> PRa : 

### Emperical analysis (`Rotenone`) {.tabset .tabset-fade .tabset-pills}

1. Use 
    - the dose of MTa data set
    - the MAP point estimator of `step_by_step_X_CIa_*.stanFit`
to predict `CIa_pred` 
1. Plot `MTa` wrt `CIa_pred`

```{r results='hide',fig.keep='all'}
tmp.stanfile.name = "step_by_step_uptoKE2_MTa_linear"
tmp.chemi = "Rotenone"

f.stanFit.filter(pattern = tmp.stanfile.name, 
                 chemi = tmp.chemi, 
                 extension = "stanFit")
tmp.stanFit.ts = f.stanFit.filter.timestamp(pattern = tmp.stanfile.name,
                                            chemi = tmp.chemi,
                           newest.first = T)
tmp.stanFit.ts

tmp.stanFit.name = f.stanFit.filter(pattern = tmp.stanFit.ts[1],
                                    chemi = tmp.chemi, 
                                    extension = "stanFit")
tmp.stanFit.name

fit_step_by_step_uptoKE2_MTa_linear =
  readr::read_rds(glob_params$Stan$f.FitPath(tmp.stanFit.name[1]))
```

The stanFit used in this section corresponds to 

- `r tmp.stanFit.name`

```{r results='hide'}
tmp.fit = fit_step_by_step_uptoKE2_MTa_linear

p.pars.CIa = c("y_min_CIa",
               "y_max_CIa",
               "x_50_CIa",
               "k_CIa",
               "sigma_CIa")

p.pars.MTa = c("beta_MTa",
               "beta_0_MTa",
               "sigma_MTa")

tmp.parsName = c(p.pars.CIa,
                 p.pars.MTa,

                 "lp__")

la_all = as.data.frame(rstan::extract(tmp.fit, pars = tmp.parsName))

la.map_all = la_all[which.max(la_all$lp__),]


la.summary_all = summary(tmp.fit,
                         probs = c(0.05, 0.95),
                         pars = tmp.parsName)$summary %>% as.data.frame()

la.summary_all$MAP = la.map_all %>% as.matrix() %>% c()
la.mean_all = la.summary_all["mean"] %>% t() %>% as.data.frame()

# ## Linking function
source(glob_params$f.RScript("CPDs.R")) ;

## Data
source(glob_params$f.RScript('load-and-reshape-Konstanz-data.R')) ;

tmp.data.KE1 = KE1.both %>% filter(., chemi == tmp.chemi, concentration_MuMol > 0)
tmp.data.KE2 = KE2.both %>% filter(., chemi == tmp.chemi, concentration_MuMol > 0)
tmp.data.KE3 = KE3.both %>% filter(., chemi == tmp.chemi, concentration_MuMol > 0)

tmp.est.ponct = la.map_all
# tmp.est.ponct = la.mean_all

# Parameters of stanFit for CIa
tmp.pars_MTa = list(beta     = tmp.est.ponct$beta_MTa,
                    beta_0   = tmp.est.ponct$beta_0_MTa)
# Parameters of stanFit for MTa
tmp.pars_CIa = list(y_min     = tmp.est.ponct$y_min_CIa,
                    y_max     = tmp.est.ponct$y_max_CIa,
                    x_50      = tmp.est.ponct$x_50_CIa %>% log(),
                    k         = tmp.est.ponct$k_CIa)

```


```{r eval = F, cache=T}
{
  p.data = tmp.data.KE1
  p = ggplot(data = p.data,
             aes(x = concentration_MuMol,
                 y = c1_activity))
  
  p +
    geom_point(aes(colour = replication)) +
    scale_x_continuous(limit=c(1E-4,50),trans = "log10") +
    scale_y_continuous(limit=c(0,150),oob=squish) 
}

{
  p.data = tmp.data.KE2
  p = ggplot(data = p.data,
             aes(x = concentration_MuMol,
                 y = mito_resp))
  
  p +
    geom_point(aes(colour = replication)) +
    scale_x_continuous(limit=c(1E-4,50),trans = "log10") +
    scale_y_continuous(limit=c(0,150),oob=squish)
}

{
  p.data = tmp.data.KE3
  p = ggplot(data = p.data,
             aes(x = concentration_MuMol,
                 y = Prot_acti))
  
  p +
    geom_point(aes(colour = replication)) +
    scale_x_continuous(limit=c(1E-4,50),trans = "log10") +
    scale_y_continuous(limit=c(0,150),oob=squish)
}

```


```{r out.width = '100%', fig.asp = 1.5, cache=T}
p.data = tmp.data.KE3

p.data$CIa_pred = log(p.data$concentration_MuMol) %>% 
    f.link.lgstc(.,
                 params = tmp.pars_CIa)

p.data$MTa_pred = 
  f.link.linear(x = p.data$CIa_pred,
                params = tmp.pars_MTa) %>% 
  f.link.truncation(., lower = 0, upper = 120) 

if(F){
  p.data$concentration_MuMol
  p.data$CIa_pred
  p.data$MTa_pred
  p.data$Prot_acti
}

tmp.p.1 = ggplot(data = p.data,
           aes(x = concentration_MuMol,
               y = CIa_pred)) +
  geom_point(aes(colour = replication)) +
    scale_x_continuous(limit=c(1E-4,50),trans = "log10") +
    scale_y_continuous(limit=c(0,150),oob=squish)

tmp.p.2 = ggplot(data = p.data,
           aes(x = CIa_pred,
               y = MTa_pred)) +
  geom_point(aes(colour = replication)) +
    scale_x_continuous(limit=c(0,120)) +
    scale_y_continuous(limit=c(0,150),oob=squish)

tmp.p.3 = ggplot(data = p.data,
           aes(x = MTa_pred,
               y = Prot_acti)) +
  geom_point(aes(colour = replication)) +
    scale_x_continuous(limit=c(0,120)) +
    scale_y_continuous(limit=c(0,150),oob=squish) +
  geom_line(aes(group = replication, colour = replication))

grid.arrange(tmp.p.1, tmp.p.2, tmp.p.3, ncol=1)

```



### Modelling MTa -> PRa

Variables are : 

- $rep_i\in \{1,2,3,4\}$ : Indexe of replication group. We have 4 replications here
- $y_{obs, rep_i}$ : experimental measurements of **PRa** (KE of interest)
- $x_{rep_i}$ : Parent node of $y$ in the AOP.

Parameters are marked in <span style="color:red">col</span><span style="color:green">ors</span> :

- red : indicates parameters that are shared by all individual data
- green : parameters that are specific to each sub-group : here sub-group corresponds to different replication groups.
  
$$\begin{equation}
\begin{split}
\color{green}{y_{max,rep_i}} &\sim \mathcal{N}(\color{red}{\mu_{y_{max}}},\, \color{red}{\sigma_{y_{max}}}^2)\\
y_{rep_i} &= \begin{cases}
\color{green}{y_{max,rep_i}}  \left( 1 - e^{-\color{red}{k}(x_{rep_i} - \color{red}{x_{min}} )} \right) & \text{if $x_{rep_i} > x_{min}$} \\
0   & \text{otherwise}
\end{cases}\\
y_{obs,rep_i} &\sim \mathcal{N}(y_{rep_i},\, \color{red}{\sigma_{y}}^2)\\
\end{split}
\end{equation}$$

### Remarks

#### 1. Interpertation of parameters

- for $i \in {1,2,3,4}$, $\color{green}{y_{max,rep_i}}$ are saturation levels for each of 4 replication groups 
    - to be discussed with the data producer whysuch difference exists
- $x_{min} \in \mathbb{R}^+$ : Minimum Effect quantity of MTa for PRa

#### 2. Hyper parameters for y_max

This is a hierarchical model :

- Introduce two hyper paramters for $\color{green}{y_{max,rep_i}}$
    - $\mu_{y_{max}}  \sim \mathcal{N} (100,\, {\sigma_{\text{user-difined}}}^2)$ : prior
    - $\sigma_{y_{max}}  \sim \mathcal{L}$ : $\mathcal{L}$ a user-defined distribution : Half-normal as suggested by F.Y.B


#### A fit by hand

```{r}
# Parameters of stanFit for CIa

tmp.est.ponct$tox_MTa_min_PRa = 11
tmp.est.ponct$k_PRa = 0.5

tmp.pars_PRa_rep1 = list(y_max     = 106,
                         x_tox_min = tmp.est.ponct$tox_MTa_min_PRa,
                         k         = tmp.est.ponct$k_PRa )

tmp.pars_PRa_rep2 = list(y_max     = 103,
                         x_tox_min = tmp.est.ponct$tox_MTa_min_PRa,
                         k         = tmp.est.ponct$k_PRa )

tmp.pars_PRa_rep3 = list(y_max     = 116,
                         x_tox_min = tmp.est.ponct$tox_MTa_min_PRa,
                         k         = tmp.est.ponct$k_PRa )

tmp.pars_PRa_rep4 = list(y_max     = 82,
                         x_tox_min = tmp.est.ponct$tox_MTa_min_PRa,
                         k         = tmp.est.ponct$k_PRa )

do.call(rbind, list(
  pars_PRa_rep1 = tmp.pars_PRa_rep1 %>% as.data.frame(),
  pars_PRa_rep2 = tmp.pars_PRa_rep2 %>% as.data.frame(),
  pars_PRa_rep3 = tmp.pars_PRa_rep3 %>% as.data.frame(),
  pars_PRa_rep4 = tmp.pars_PRa_rep4 %>% as.data.frame())
) %>% DT::datatable(.,options = list(pageLength = dim(.)[1]))

```

```{r}
p.data = tmp.data.KE3

p.data$CIa_pred = log(p.data$concentration_MuMol) %>%
    f.link.lgstc(.,
                 params = tmp.pars_CIa)

p.data$MTa_pred =
  f.link.linear(x = p.data$CIa_pred,
                params = tmp.pars_MTa) %>%
  f.link.truncation(., lower = 0, upper = 120)

ggplot(data = p.data,
           aes(x = MTa_pred,
               y = Prot_acti,
               colour = replication)) +
  geom_point() +
    scale_x_continuous(limit=c(0,120)) +
    scale_y_continuous(limit=c(0,150),oob=squish) +
  stat_function(data = . %>% filter(replication == "Prot. acti., N1"),
                fun = function(x) f.link.exp_tox_min(x,
                                               params = tmp.pars_PRa_rep1)) +
    stat_function(data = . %>% filter(replication == "Prot. acti., N2"),
                fun = function(x) f.link.exp_tox_min(x,
                                               params = tmp.pars_PRa_rep2)) +
    stat_function(data = . %>% filter(replication == "Prot. acti., N3"),
                fun = function(x) f.link.exp_tox_min(x,
                                               params = tmp.pars_PRa_rep3)) +
    stat_function(data = . %>% filter(replication == "Prot. acti., N4"),
                fun = function(x) f.link.exp_tox_min(x,
                                               params = tmp.pars_PRa_rep4))

```



## Cleanup

```{r}
cleanup()
rm(p.data)
rm(fit_step_by_step_uptoKE2_MTa_linear)
```

----

----

# Analysis of fit

## Rotenone {.tabset .tabset-fade .tabset-pills}

### Load previous fit

```{r include=T, cache = FALSE, results='hide'}
tmp.stanfile.name = "step_by_step_uptoKE3_PRa_Hierarchical_Exp"
tmp.chemi = "Rotenone"

f.stanFit.filter(pattern = tmp.stanfile.name, 
                 chemi = tmp.chemi, 
                 extension = "stanFit")
tmp.stanFit.ts = f.stanFit.filter.timestamp(pattern = tmp.stanfile.name,
                                            chemi = tmp.chemi,
                           newest.first = T)
tmp.stanFit.ts

tmp.stanFit.name = f.stanFit.filter(pattern = tmp.stanFit.ts[1],
                                    chemi = tmp.chemi, 
                                    extension = "stanFit")
tmp.stanFit.name

fit_step_by_step_uptoKE3_PRa_Hierarchical_Exp =
  readr::read_rds(glob_params$Stan$f.FitPath(tmp.stanFit.name[1]))
```

The stanFit used in this report corresponds to 

- `r tmp.stanFit.name[1]`



### Posterior summary

```{r eval = F}
fit_step_by_step_uptoKE3_PRa_Hierarchical_Exp
check_hmc_diagnostics(fit_step_by_step_uptoKE3_PRa_Hierarchical_Exp)
```


```{r}
tmp.fit = fit_step_by_step_uptoKE3_PRa_Hierarchical_Exp

p.pars.CIa = c("CIa_min" ,
               "CIa_max" ,
               "Par_CIa_50" ,
               "log_Par_CIa_50",
               "k_CIa" ,
               "sigma_CIa")

p.pars.MTa = c("beta_MTa",
               "beta_0_MTa",
               "sigma_MTa")

p.pars.PRa = c( "mean_PRa_max",
                "sd_PRa_max",
                "PRa_max_rep1",
                "PRa_max_rep2",
                "PRa_max_rep3",
                "PRa_max_rep4",
                "tox_MTa_min_PRa",
                # "q_PRa",
                "k_PRa",
                "sigma_PRa")

tmp.parsName = c(p.pars.CIa,
                 p.pars.MTa,
                 p.pars.PRa,
                 
                 "lp__")

la_all = as.data.frame(rstan::extract(tmp.fit, pars = tmp.parsName))

la.map_all = la_all[which.max(la_all$lp__),]


la.summary_all = summary(tmp.fit,
                         probs = c(0.05, 0.95),
                         pars = tmp.parsName)$summary %>% as.data.frame()

la.summary_all$MAP = la.map_all %>% as.matrix() %>% c()
la.mean_all = la.summary_all["mean"] %>% t() %>% as.data.frame()

la.summary_all = la.summary_all %>% select(MAP, mean,se_mean, sd, `5%`, `95%`,n_eff,Rhat)

# options("scipen"= 2,digits=5)
# options("scipen"= 0,digits=7)
la.summary_all %>% round(.,digits = 3) %>%  DT::datatable(.,options = list(pageLength = dim(.)[1]))
```

### Diagnostic {.tabset .tabset-fade .tabset-pills}

```{r}
posterior2 <- rstan::extract(tmp.fit,
                             # inc_warmup = TRUE,
                             permuted = FALSE)
library(bayesplot)
color_scheme_set("mix-blue-pink")
```

#### ShinyStan

```{r eval=F, echo=T}
shinystan::launch_shinystan(tmp.fit)
```
#### CIa {.tabset .tabset-fade .tabset-pills}

##### Traceplots

```{r}
p <- mcmc_trace(posterior2,
                pars =  p.pars.CIa,
                # n_warmup = dim(posterior2)[1]/2 %>% floor(),
                facet_args = list(nrow = 2, labeller = label_parsed))
p + facet_text(size = 15)
```

##### Posterior distribution

```{r}
# mcmc_hist_by_chain(posterior2,
#                    pars = p.pars,
#                   # n_warmup = dim(posterior2)[1]/2 %>% floor(),
#                   facet_args = list(labeller = label_parsed))

mcmc_hist(posterior2,
          pars = p.pars.CIa,
          facet_args = list(nrow = 2, labeller = label_parsed))

# stan_hist(tmp.fit)
```


##### Autocorrelation

```{r}
stan_ac(tmp.fit, pars = p.pars.CIa)
```


#### MTa {.tabset .tabset-fade .tabset-pills}

##### Traceplots

```{r}
p <- mcmc_trace(posterior2,
                pars =  p.pars.MTa,
                # n_warmup = dim(posterior2)[1]/2 %>% floor(),
                facet_args = list(nrow = 2, labeller = label_parsed))
p + facet_text(size = 15)
```

##### Posterior distribution

```{r}
mcmc_hist(posterior2,
          pars = p.pars.MTa,
          facet_args = list(nrow = 2, labeller = label_parsed))
```


##### Autocorrelation

```{r}
stan_ac(tmp.fit, pars = p.pars.MTa)
```


#### PRa {.tabset .tabset-fade .tabset-pills}

**PRa_min** and **PRa_max** are preset to be $0$. 

##### Traceplots

```{r}
p <- mcmc_trace(posterior2,
                pars = p.pars.PRa,
                # n_warmup = dim(posterior2)[1]/2 %>% floor(),
                facet_args = list(nrow = 4, labeller = label_parsed))
p + facet_text(size = 15)

```

##### Posterior distribution

```{r}
# mcmc_hist_by_chain(posterior2,
#                    pars = p.pars,
#                   # n_warmup = dim(posterior2)[1]/2 %>% floor(),
#                   facet_args = list(labeller = label_parsed))

mcmc_hist(posterior2,
          pars = p.pars.PRa,
          facet_args = list(nrow = 2, labeller = label_parsed))

# stan_hist(tmp.fit)
```

##### Autocorrelation

```{r}
stan_ac(tmp.fit, pars = p.pars.PRa)
```

### Visual validation {.tabset .tabset-fade .tabset-pills}

**Linking functions**

```{r eval = F, code = readLines(glob_params$f.RScript("CPDs.R"))}
```

```{r include=F}
source(glob_params$f.RScript("CPDs.R"))
source(glob_params$f.RScript('load-and-reshape-Konstanz-data.R'))
tmp.chemi = "Rotenone"
tmp.data.KE1 = KE1.both %>% filter(., chemi == tmp.chemi, concentration_MuMol > 0)
tmp.data.KE2 = KE2.both %>% filter(., chemi == tmp.chemi, concentration_MuMol > 0)
tmp.data.KE3 = KE3.both %>% filter(., chemi == tmp.chemi, concentration_MuMol > 0)
```

#### X->CIa {.tabset .tabset-fade .tabset-pills}

##### Prediction with MAP

**Maximum _a posteriori_**

```{r}
options("scipen"= 6, digits=2)
tmp.est.ponct = la.map_all
# tmp.est.ponct = la.mean_all ; la.mean_all %>% t()

# Parameters of stanFit for CIa
tmp.pars_CIa = list(y_min     = tmp.est.ponct$CIa_min,
                    y_max     = tmp.est.ponct$CIa_max,
                    x_50      = tmp.est.ponct$log_Par_CIa_50,
                    k         = tmp.est.ponct$k_CIa)

tmp.pars_CIa %>% as.data.frame()
```

```{r}
p = ggplot(data = tmp.data.KE1,
           aes(x = concentration_MuMol,
               y = c1_activity))

p +
  geom_point(aes(colour = replication)) +
  scale_y_continuous(limit=c(0,NA),oob=squish) +
  scale_x_continuous(trans = "log10") +
  stat_function(fun = function(x) f.link.lgstc(log(x),
                                               params = tmp.pars_CIa))
```

##### Prediction with Post-Mean

**Posterior Mean**

```{r}
options("scipen"= 6, digits=2)
tmp.est.ponct = la.mean_all

# Parameters of stanFit for CIa
tmp.pars_CIa = list(y_min     = tmp.est.ponct$CIa_min,
                    y_max     = tmp.est.ponct$CIa_max,
                    x_50      = tmp.est.ponct$log_Par_CIa_50,
                    k         = tmp.est.ponct$k_CIa)

tmp.pars_CIa %>% as.data.frame()
```

```{r}
p = ggplot(data = tmp.data.KE1,
           aes(x = concentration_MuMol,
               y = c1_activity))

p +
  geom_point(aes(colour = replication)) +
  scale_y_continuous(limit=c(0,NA),oob=squish) +
  scale_x_continuous(trans = "log10") +
  stat_function(fun = function(x) f.link.lgstc(log(x),
                                               params = tmp.pars_CIa))
```

#### CIa -> MTa {.tabset .tabset-fade .tabset-pills}

##### Prediction with MAP

**Maximum _a posteriori_**

```{r}
options("scipen"= 6, digits=2)
tmp.est.ponct = la.map_all
# tmp.est.ponct = la.mean_all

# Parameters of stanFit for CIa
tmp.pars_CIa = list(y_min     = tmp.est.ponct$CIa_min,
                    y_max     = tmp.est.ponct$CIa_max,
                    x_50      = tmp.est.ponct$log_Par_CIa_50,
                    k         = tmp.est.ponct$k_CIa)
tmp.pars_MTa = list(beta     = tmp.est.ponct$beta_MTa,
                    beta_0   = tmp.est.ponct$beta_0_MTa)

tmp.pars_MTa %>% as.data.frame()
```

```{r}
p = ggplot(data = tmp.data.KE2,
           aes(x = f.link.lgstc(log(concentration_MuMol), params = tmp.pars_CIa),
               y = mito_resp))

p +
  geom_point(aes(colour = replication)) +
  scale_x_continuous(limit=c(0,NA),oob=squish) +
  scale_y_continuous(limit=c(0,NA),oob=squish) +
  stat_function(fun = function(x)
    f.link.linear(x,
                  params = tmp.pars_MTa) %>%
      f.link.truncation(., lower = 0, upper = 120))

```


##### Prediction with Post-Mean

**Posterior Mean**

```{r}
options("scipen"= 6, digits=2)
tmp.est.ponct = la.mean_all

# Parameters of stanFit for CIa
tmp.pars_CIa = list(y_min     = tmp.est.ponct$CIa_min,
                    y_max     = tmp.est.ponct$CIa_max,
                    x_50      = tmp.est.ponct$log_Par_CIa_50,
                    k         = tmp.est.ponct$k_CIa)
tmp.pars_MTa = list(beta     = tmp.est.ponct$beta_MTa,
                    beta_0   = tmp.est.ponct$beta_0_MTa)
tmp.pars_MTa %>% as.data.frame()
```

```{r}
p = ggplot(data = tmp.data.KE2,
           aes(x = f.link.lgstc(log(concentration_MuMol), params = tmp.pars_CIa),
               y = mito_resp))

p +
  geom_point(aes(colour = replication)) +
  scale_x_continuous(limit=c(0,NA),oob=squish) +
  scale_y_continuous(limit=c(0,NA),oob=squish) +
  stat_function(fun = function(x)
    f.link.linear(x,
                  params = tmp.pars_MTa) %>%
      f.link.truncation(., lower = 0, upper = 120))

```

#### MTa -> PRa {.tabset .tabset-fade .tabset-pills}

##### Prediction with MAP

**Maximum _a posteriori_**

```{r}
options("scipen"= 6, digits=2)
tmp.est.ponct = la.map_all
# tmp.est.ponct = la.mean_all

# Parameters of stanFit for CIa
tmp.pars_CIa = list(y_min     = tmp.est.ponct$CIa_min,
                    y_max     = tmp.est.ponct$CIa_max,
                    x_50      = tmp.est.ponct$log_Par_CIa_50,
                    k         = tmp.est.ponct$k_CIa)
tmp.pars_MTa = list(beta     = tmp.est.ponct$beta_MTa,
                    beta_0   = tmp.est.ponct$beta_0_MTa)
tmp.pars_PRa_rep1 = list(y_max     = tmp.est.ponct$PRa_max_rep1,
                         x_tox_min = tmp.est.ponct$tox_MTa_min_PRa,
                         k         = tmp.est.ponct$k_PRa )

tmp.pars_PRa_rep2 = list(y_max     = tmp.est.ponct$PRa_max_rep2,
                         x_tox_min = tmp.est.ponct$tox_MTa_min_PRa,
                         k         = tmp.est.ponct$k_PRa )

tmp.pars_PRa_rep3 = list(y_max     = tmp.est.ponct$PRa_max_rep3,
                         x_tox_min = tmp.est.ponct$tox_MTa_min_PRa,
                         k         = tmp.est.ponct$k_PRa )

tmp.pars_PRa_rep4 = list(y_max     = tmp.est.ponct$PRa_max_rep4,
                         x_tox_min = tmp.est.ponct$tox_MTa_min_PRa,
                         k         = tmp.est.ponct$k_PRa )

do.call(rbind, list(
  pars_PRa_rep1 = tmp.pars_PRa_rep1 %>% as.data.frame(),
  pars_PRa_rep2 = tmp.pars_PRa_rep2 %>% as.data.frame(),
  pars_PRa_rep3 = tmp.pars_PRa_rep3 %>% as.data.frame(),
  pars_PRa_rep4 = tmp.pars_PRa_rep4 %>% as.data.frame())
) %>% DT::datatable(.,options = list(pageLength = dim(.)[1]))
```

```{r}
p.data = tmp.data.KE3

p.data$CIa_pred = log(p.data$concentration_MuMol) %>%
    f.link.lgstc(.,
                 params = tmp.pars_CIa)

p.data$MTa_pred =
  f.link.linear(x = p.data$CIa_pred,
                params = tmp.pars_MTa) %>%
  f.link.truncation(., lower = 0, upper = 120)

ggplot(data = p.data,
           aes(x = MTa_pred,
               y = Prot_acti,
               colour = replication)) +
  geom_point() +
    scale_x_continuous(limit=c(0,120)) +
    scale_y_continuous(limit=c(0,150),oob=squish) +
  stat_function(data = . %>% filter(replication == "Prot. acti., N1"),
                fun = function(x) f.link.exp_tox_min(x,
                                               params = tmp.pars_PRa_rep1)) +
    stat_function(data = . %>% filter(replication == "Prot. acti., N2"),
                fun = function(x) f.link.exp_tox_min(x,
                                               params = tmp.pars_PRa_rep2)) +
    stat_function(data = . %>% filter(replication == "Prot. acti., N3"),
                fun = function(x) f.link.exp_tox_min(x,
                                               params = tmp.pars_PRa_rep3)) +
    stat_function(data = . %>% filter(replication == "Prot. acti., N4"),
                fun = function(x) f.link.exp_tox_min(x,
                                               params = tmp.pars_PRa_rep4))

```


##### Prediction with Post-Mean

**Posterior Mean**

```{r}
options("scipen"= 6, digits=2)
# tmp.est.ponct = la.map_all
tmp.est.ponct = la.mean_all

# Parameters of stanFit for CIa
tmp.pars_CIa = list(y_min     = tmp.est.ponct$CIa_min,
                    y_max     = tmp.est.ponct$CIa_max,
                    x_50      = tmp.est.ponct$log_Par_CIa_50,
                    k         = tmp.est.ponct$k_CIa)
tmp.pars_MTa = list(beta     = tmp.est.ponct$beta_MTa,
                    beta_0   = tmp.est.ponct$beta_0_MTa)
tmp.pars_PRa_rep1 = list(y_max     = tmp.est.ponct$PRa_max_rep1,
                         x_tox_min = tmp.est.ponct$tox_MTa_min_PRa,
                         k         = tmp.est.ponct$k_PRa )

tmp.pars_PRa_rep2 = list(y_max     = tmp.est.ponct$PRa_max_rep2,
                         x_tox_min = tmp.est.ponct$tox_MTa_min_PRa,
                         k         = tmp.est.ponct$k_PRa )

tmp.pars_PRa_rep3 = list(y_max     = tmp.est.ponct$PRa_max_rep3,
                         x_tox_min = tmp.est.ponct$tox_MTa_min_PRa,
                         k         = tmp.est.ponct$k_PRa )

tmp.pars_PRa_rep4 = list(y_max     = tmp.est.ponct$PRa_max_rep4,
                         x_tox_min = tmp.est.ponct$tox_MTa_min_PRa,
                         k         = tmp.est.ponct$k_PRa )

do.call(rbind, list(
  pars_PRa_rep1 = tmp.pars_PRa_rep1 %>% as.data.frame(),
  pars_PRa_rep2 = tmp.pars_PRa_rep2 %>% as.data.frame(),
  pars_PRa_rep3 = tmp.pars_PRa_rep3 %>% as.data.frame(),
  pars_PRa_rep4 = tmp.pars_PRa_rep4 %>% as.data.frame())
) %>% DT::datatable(.,options = list(pageLength = dim(.)[1]))
```

```{r}
p.data = tmp.data.KE3

p.data$CIa_pred = log(p.data$concentration_MuMol) %>%
    f.link.lgstc(.,
                 params = tmp.pars_CIa)

p.data$MTa_pred =
  f.link.linear(x = p.data$CIa_pred,
                params = tmp.pars_MTa) %>%
  f.link.truncation(., lower = 0, upper = 120)

ggplot(data = p.data,
           aes(x = MTa_pred,
               y = Prot_acti,
               colour = replication)) +
  geom_point() +
    scale_x_continuous(limit=c(0,120)) +
    scale_y_continuous(limit=c(0,150),oob=squish) +
  stat_function(data = . %>% filter(replication == "Prot. acti., N1"),
                fun = function(x) f.link.exp_tox_min(x,
                                               params = tmp.pars_PRa_rep1)) +
    stat_function(data = . %>% filter(replication == "Prot. acti., N2"),
                fun = function(x) f.link.exp_tox_min(x,
                                               params = tmp.pars_PRa_rep2)) +
    stat_function(data = . %>% filter(replication == "Prot. acti., N3"),
                fun = function(x) f.link.exp_tox_min(x,
                                               params = tmp.pars_PRa_rep3)) +
    stat_function(data = . %>% filter(replication == "Prot. acti., N4"),
                fun = function(x) f.link.exp_tox_min(x,
                                               params = tmp.pars_PRa_rep4))

```

---

---

## Deguelin {.tabset .tabset-fade .tabset-pills}

### Load previous fit

```{r include=T, cache = FALSE, results='hide'}
tmp.stanfile.name = "step_by_step_uptoKE3_PRa_Hierarchical_Exp"
tmp.chemi = "Deguelin"

f.stanFit.filter(pattern = tmp.stanfile.name, 
                 chemi = tmp.chemi, 
                 extension = "stanFit")
tmp.stanFit.ts = f.stanFit.filter.timestamp(pattern = tmp.stanfile.name,
                                            chemi = tmp.chemi,
                           newest.first = T)
tmp.stanFit.ts

tmp.stanFit.name = f.stanFit.filter(pattern = tmp.stanFit.ts[1],
                                    chemi = tmp.chemi, 
                                    extension = "stanFit")
tmp.stanFit.name

fit_step_by_step_uptoKE3_PRa_Hierarchical_Exp =
  readr::read_rds(glob_params$Stan$f.FitPath(tmp.stanFit.name[1]))
```

The stanFit used in this report corresponds to 

- `r tmp.stanFit.name[1]`



### Posterior summary

```{r eval = F}
fit_step_by_step_uptoKE3_PRa_Hierarchical_Exp
check_hmc_diagnostics(fit_step_by_step_uptoKE3_PRa_Hierarchical_Exp)
```


```{r}
tmp.fit = fit_step_by_step_uptoKE3_PRa_Hierarchical_Exp

p.pars.CIa = c("CIa_min" ,
               "CIa_max" ,
               "Par_CIa_50" ,
               "log_Par_CIa_50",
               "k_CIa" ,
               "sigma_CIa")

p.pars.MTa = c("beta_MTa",
               "beta_0_MTa",
               "sigma_MTa")

p.pars.PRa = c( "mean_PRa_max",
                "sd_PRa_max",
                "PRa_max_rep1",
                "PRa_max_rep2",
                "PRa_max_rep3",
                "PRa_max_rep4",
                "tox_MTa_min_PRa",
                # "q_PRa",
                "k_PRa",
                "sigma_PRa")

tmp.parsName = c(p.pars.CIa,
                 p.pars.MTa,
                 p.pars.PRa,
                 
                 "lp__")

la_all = as.data.frame(rstan::extract(tmp.fit, pars = tmp.parsName))

la.map_all = la_all[which.max(la_all$lp__),]


la.summary_all = summary(tmp.fit,
                         probs = c(0.05, 0.95),
                         pars = tmp.parsName)$summary %>% as.data.frame()

la.summary_all$MAP = la.map_all %>% as.matrix() %>% c()
la.mean_all = la.summary_all["mean"] %>% t() %>% as.data.frame()

la.summary_all = la.summary_all %>% select(MAP, mean,se_mean, sd, `5%`, `95%`,n_eff,Rhat)

# options("scipen"= 2,digits=5)
# options("scipen"= 0,digits=7)
la.summary_all %>% round(.,digits = 3) %>%  DT::datatable(.,options = list(pageLength = dim(.)[1]))
```

### Diagnostic {.tabset .tabset-fade .tabset-pills}

```{r}
posterior2 <- rstan::extract(tmp.fit,
                             # inc_warmup = TRUE,
                             permuted = FALSE)
library(bayesplot)
color_scheme_set("mix-blue-pink")
```

#### ShinyStan

```{r eval=F, echo=T}
shinystan::launch_shinystan(tmp.fit)
```
#### CIa {.tabset .tabset-fade .tabset-pills}

##### Traceplots

```{r}
p <- mcmc_trace(posterior2,
                pars =  p.pars.CIa,
                # n_warmup = dim(posterior2)[1]/2 %>% floor(),
                facet_args = list(nrow = 2, labeller = label_parsed))
p + facet_text(size = 15)
```

##### Posterior distribution

```{r}
# mcmc_hist_by_chain(posterior2,
#                    pars = p.pars,
#                   # n_warmup = dim(posterior2)[1]/2 %>% floor(),
#                   facet_args = list(labeller = label_parsed))

mcmc_hist(posterior2,
          pars = p.pars.CIa,
          facet_args = list(nrow = 2, labeller = label_parsed))

# stan_hist(tmp.fit)
```


##### Autocorrelation

```{r}
stan_ac(tmp.fit, pars = p.pars.CIa)
```


#### MTa {.tabset .tabset-fade .tabset-pills}

##### Traceplots

```{r}
p <- mcmc_trace(posterior2,
                pars =  p.pars.MTa,
                # n_warmup = dim(posterior2)[1]/2 %>% floor(),
                facet_args = list(nrow = 2, labeller = label_parsed))
p + facet_text(size = 15)
```

##### Posterior distribution

```{r}
mcmc_hist(posterior2,
          pars = p.pars.MTa,
          facet_args = list(nrow = 2, labeller = label_parsed))
```


##### Autocorrelation

```{r}
stan_ac(tmp.fit, pars = p.pars.MTa)
```


#### PRa {.tabset .tabset-fade .tabset-pills}

**PRa_min** and **PRa_max** are preset to be $0$. 

##### Traceplots

```{r}
p <- mcmc_trace(posterior2,
                pars = p.pars.PRa,
                # n_warmup = dim(posterior2)[1]/2 %>% floor(),
                facet_args = list(nrow = 4, labeller = label_parsed))
p + facet_text(size = 15)

```

##### Posterior distribution

```{r}
# mcmc_hist_by_chain(posterior2,
#                    pars = p.pars,
#                   # n_warmup = dim(posterior2)[1]/2 %>% floor(),
#                   facet_args = list(labeller = label_parsed))

mcmc_hist(posterior2,
          pars = p.pars.PRa,
          facet_args = list(nrow = 2, labeller = label_parsed))

# stan_hist(tmp.fit)
```

##### Autocorrelation

```{r}
stan_ac(tmp.fit, pars = p.pars.PRa)
```

### Visual validation {.tabset .tabset-fade .tabset-pills}

**Linking functions**

```{r eval = F, code = readLines(glob_params$f.RScript("CPDs.R"))}
```

```{r include=F}
source(glob_params$f.RScript("CPDs.R"))
source(glob_params$f.RScript('load-and-reshape-Konstanz-data.R'))
tmp.chemi = "Deguelin"
tmp.data.KE1 = KE1.both %>% filter(., chemi == tmp.chemi, concentration_MuMol > 0)
tmp.data.KE2 = KE2.both %>% filter(., chemi == tmp.chemi, concentration_MuMol > 0)
tmp.data.KE3 = KE3.both %>% filter(., chemi == tmp.chemi, concentration_MuMol > 0)
```

#### X->CIa {.tabset .tabset-fade .tabset-pills}

##### Prediction with MAP

**Maximum _a posteriori_**

```{r}
options("scipen"= 6, digits=2)
tmp.est.ponct = la.map_all
# tmp.est.ponct = la.mean_all ; la.mean_all %>% t()

# Parameters of stanFit for CIa
tmp.pars_CIa = list(y_min     = tmp.est.ponct$CIa_min,
                    y_max     = tmp.est.ponct$CIa_max,
                    x_50      = tmp.est.ponct$log_Par_CIa_50,
                    k         = tmp.est.ponct$k_CIa)

tmp.pars_CIa %>% as.data.frame()
```

```{r}
p = ggplot(data = tmp.data.KE1,
           aes(x = concentration_MuMol,
               y = c1_activity))

p +
  geom_point(aes(colour = replication)) +
  scale_y_continuous(limit=c(0,NA),oob=squish) +
  scale_x_continuous(trans = "log10") +
  stat_function(fun = function(x) f.link.lgstc(log(x),
                                               params = tmp.pars_CIa))
```

##### Prediction with Post-Mean

**Posterior Mean**

```{r}
options("scipen"= 6, digits=2)
tmp.est.ponct = la.mean_all

# Parameters of stanFit for CIa
tmp.pars_CIa = list(y_min     = tmp.est.ponct$CIa_min,
                    y_max     = tmp.est.ponct$CIa_max,
                    x_50      = tmp.est.ponct$log_Par_CIa_50,
                    k         = tmp.est.ponct$k_CIa)

tmp.pars_CIa %>% as.data.frame()
```

```{r}
p = ggplot(data = tmp.data.KE1,
           aes(x = concentration_MuMol,
               y = c1_activity))

p +
  geom_point(aes(colour = replication)) +
  scale_y_continuous(limit=c(0,NA),oob=squish) +
  scale_x_continuous(trans = "log10") +
  stat_function(fun = function(x) f.link.lgstc(log(x),
                                               params = tmp.pars_CIa))
```

#### CIa -> MTa {.tabset .tabset-fade .tabset-pills}

##### Prediction with MAP

**Maximum _a posteriori_**

```{r}
options("scipen"= 6, digits=2)
tmp.est.ponct = la.map_all
# tmp.est.ponct = la.mean_all

# Parameters of stanFit for CIa
tmp.pars_CIa = list(y_min     = tmp.est.ponct$CIa_min,
                    y_max     = tmp.est.ponct$CIa_max,
                    x_50      = tmp.est.ponct$log_Par_CIa_50,
                    k         = tmp.est.ponct$k_CIa)
tmp.pars_MTa = list(beta     = tmp.est.ponct$beta_MTa,
                    beta_0   = tmp.est.ponct$beta_0_MTa)

tmp.pars_MTa %>% as.data.frame()
```

```{r}
p = ggplot(data = tmp.data.KE2,
           aes(x = f.link.lgstc(log(concentration_MuMol), params = tmp.pars_CIa),
               y = mito_resp))

p +
  geom_point(aes(colour = replication)) +
  scale_x_continuous(limit=c(0,NA),oob=squish) +
  scale_y_continuous(limit=c(0,NA),oob=squish) +
  stat_function(fun = function(x)
    f.link.linear(x,
                  params = tmp.pars_MTa) %>%
      f.link.truncation(., lower = 0, upper = 120))

```


##### Prediction with Post-Mean

**Posterior Mean**

```{r}
options("scipen"= 6, digits=2)
tmp.est.ponct = la.mean_all

# Parameters of stanFit for CIa
tmp.pars_CIa = list(y_min     = tmp.est.ponct$CIa_min,
                    y_max     = tmp.est.ponct$CIa_max,
                    x_50      = tmp.est.ponct$log_Par_CIa_50,
                    k         = tmp.est.ponct$k_CIa)
tmp.pars_MTa = list(beta     = tmp.est.ponct$beta_MTa,
                    beta_0   = tmp.est.ponct$beta_0_MTa)
tmp.pars_MTa %>% as.data.frame()
```

```{r}
p = ggplot(data = tmp.data.KE2,
           aes(x = f.link.lgstc(log(concentration_MuMol), params = tmp.pars_CIa),
               y = mito_resp))

p +
  geom_point(aes(colour = replication)) +
  scale_x_continuous(limit=c(0,NA),oob=squish) +
  scale_y_continuous(limit=c(0,NA),oob=squish) +
  stat_function(fun = function(x)
    f.link.linear(x,
                  params = tmp.pars_MTa) %>%
      f.link.truncation(., lower = 0, upper = 120))

```

#### MTa -> PRa {.tabset .tabset-fade .tabset-pills}

##### Prediction with MAP

**Maximum _a posteriori_**

```{r}
options("scipen"= 6, digits=2)
tmp.est.ponct = la.map_all
# tmp.est.ponct = la.mean_all

# Parameters of stanFit for CIa
tmp.pars_CIa = list(y_min     = tmp.est.ponct$CIa_min,
                    y_max     = tmp.est.ponct$CIa_max,
                    x_50      = tmp.est.ponct$log_Par_CIa_50,
                    k         = tmp.est.ponct$k_CIa)
tmp.pars_MTa = list(beta     = tmp.est.ponct$beta_MTa,
                    beta_0   = tmp.est.ponct$beta_0_MTa)
tmp.pars_PRa_rep1 = list(y_max     = tmp.est.ponct$PRa_max_rep1,
                         x_tox_min = tmp.est.ponct$tox_MTa_min_PRa,
                         k         = tmp.est.ponct$k_PRa )

tmp.pars_PRa_rep2 = list(y_max     = tmp.est.ponct$PRa_max_rep2,
                         x_tox_min = tmp.est.ponct$tox_MTa_min_PRa,
                         k         = tmp.est.ponct$k_PRa )

tmp.pars_PRa_rep3 = list(y_max     = tmp.est.ponct$PRa_max_rep3,
                         x_tox_min = tmp.est.ponct$tox_MTa_min_PRa,
                         k         = tmp.est.ponct$k_PRa )

tmp.pars_PRa_rep4 = list(y_max     = tmp.est.ponct$PRa_max_rep4,
                         x_tox_min = tmp.est.ponct$tox_MTa_min_PRa,
                         k         = tmp.est.ponct$k_PRa )

do.call(rbind, list(
  pars_PRa_rep1 = tmp.pars_PRa_rep1 %>% as.data.frame(),
  pars_PRa_rep2 = tmp.pars_PRa_rep2 %>% as.data.frame(),
  pars_PRa_rep3 = tmp.pars_PRa_rep3 %>% as.data.frame(),
  pars_PRa_rep4 = tmp.pars_PRa_rep4 %>% as.data.frame())
) %>% DT::datatable(.,options = list(pageLength = dim(.)[1]))
```

```{r}
p.data = tmp.data.KE3

p.data$CIa_pred = log(p.data$concentration_MuMol) %>%
    f.link.lgstc(.,
                 params = tmp.pars_CIa)

p.data$MTa_pred =
  f.link.linear(x = p.data$CIa_pred,
                params = tmp.pars_MTa) %>%
  f.link.truncation(., lower = 0, upper = 120)

ggplot(data = p.data,
           aes(x = MTa_pred,
               y = Prot_acti,
               colour = replication)) +
  geom_point() +
    scale_x_continuous(limit=c(0,120)) +
    scale_y_continuous(limit=c(0,150),oob=squish) +
  stat_function(data = . %>% filter(replication == "Prot. acti., N1"),
                fun = function(x) f.link.exp_tox_min(x,
                                               params = tmp.pars_PRa_rep1)) +
    stat_function(data = . %>% filter(replication == "Prot. acti., N2"),
                fun = function(x) f.link.exp_tox_min(x,
                                               params = tmp.pars_PRa_rep2)) +
    stat_function(data = . %>% filter(replication == "Prot. acti., N3"),
                fun = function(x) f.link.exp_tox_min(x,
                                               params = tmp.pars_PRa_rep3)) +
    stat_function(data = . %>% filter(replication == "Prot. acti., N4"),
                fun = function(x) f.link.exp_tox_min(x,
                                               params = tmp.pars_PRa_rep4))

```


##### Prediction with Post-Mean

**Posterior Mean**

```{r}
options("scipen"= 6, digits=2)
# tmp.est.ponct = la.map_all
tmp.est.ponct = la.mean_all

# Parameters of stanFit for CIa
tmp.pars_CIa = list(y_min     = tmp.est.ponct$CIa_min,
                    y_max     = tmp.est.ponct$CIa_max,
                    x_50      = tmp.est.ponct$log_Par_CIa_50,
                    k         = tmp.est.ponct$k_CIa)
tmp.pars_MTa = list(beta     = tmp.est.ponct$beta_MTa,
                    beta_0   = tmp.est.ponct$beta_0_MTa)
tmp.pars_PRa_rep1 = list(y_max     = tmp.est.ponct$PRa_max_rep1,
                         x_tox_min = tmp.est.ponct$tox_MTa_min_PRa,
                         k         = tmp.est.ponct$k_PRa )

tmp.pars_PRa_rep2 = list(y_max     = tmp.est.ponct$PRa_max_rep2,
                         x_tox_min = tmp.est.ponct$tox_MTa_min_PRa,
                         k         = tmp.est.ponct$k_PRa )

tmp.pars_PRa_rep3 = list(y_max     = tmp.est.ponct$PRa_max_rep3,
                         x_tox_min = tmp.est.ponct$tox_MTa_min_PRa,
                         k         = tmp.est.ponct$k_PRa )

tmp.pars_PRa_rep4 = list(y_max     = tmp.est.ponct$PRa_max_rep4,
                         x_tox_min = tmp.est.ponct$tox_MTa_min_PRa,
                         k         = tmp.est.ponct$k_PRa )

do.call(rbind, list(
  pars_PRa_rep1 = tmp.pars_PRa_rep1 %>% as.data.frame(),
  pars_PRa_rep2 = tmp.pars_PRa_rep2 %>% as.data.frame(),
  pars_PRa_rep3 = tmp.pars_PRa_rep3 %>% as.data.frame(),
  pars_PRa_rep4 = tmp.pars_PRa_rep4 %>% as.data.frame())
) %>% DT::datatable(.,options = list(pageLength = dim(.)[1]))
```

```{r}
p.data = tmp.data.KE3

p.data$CIa_pred = log(p.data$concentration_MuMol) %>%
    f.link.lgstc(.,
                 params = tmp.pars_CIa)

p.data$MTa_pred =
  f.link.linear(x = p.data$CIa_pred,
                params = tmp.pars_MTa) %>%
  f.link.truncation(., lower = 0, upper = 120)

ggplot(data = p.data,
           aes(x = MTa_pred,
               y = Prot_acti,
               colour = replication)) +
  geom_point() +
    scale_x_continuous(limit=c(0,120)) +
    scale_y_continuous(limit=c(0,150),oob=squish) +
  stat_function(data = . %>% filter(replication == "Prot. acti., N1"),
                fun = function(x) f.link.exp_tox_min(x,
                                               params = tmp.pars_PRa_rep1)) +
    stat_function(data = . %>% filter(replication == "Prot. acti., N2"),
                fun = function(x) f.link.exp_tox_min(x,
                                               params = tmp.pars_PRa_rep2)) +
    stat_function(data = . %>% filter(replication == "Prot. acti., N3"),
                fun = function(x) f.link.exp_tox_min(x,
                                               params = tmp.pars_PRa_rep3)) +
    stat_function(data = . %>% filter(replication == "Prot. acti., N4"),
                fun = function(x) f.link.exp_tox_min(x,
                                               params = tmp.pars_PRa_rep4))

```


```{r echo=F, results='hide'}
cleanup()
```

